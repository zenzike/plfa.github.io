<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Denot: Denotational semantics for the untyped lambda calculus | Programming Language Foundations in Agda
</title><!-- Begin Jekyll SEO tag v2.5.0 -->
<meta name="generator" content="Jekyll v3.8.5" />
<meta property="og:title" content="Denot: Denotational semantics for the untyped lambda calculus" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="Programming Language Foundations in Agda" />
<meta property="og:description" content="Programming Language Foundations in Agda" />
<link rel="canonical" href="https://plfa.github.io/Denot/" />
<meta property="og:url" content="https://plfa.github.io/Denot/" />
<meta property="og:site_name" content="Programming Language Foundations in Agda" />
<script type="application/ld+json">
{"description":"Programming Language Foundations in Agda","@type":"WebPage","url":"https://plfa.github.io/Denot/","headline":"Denot: Denotational semantics for the untyped lambda calculus","@context":"http://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"></head>
<body><header class="site-header" role="banner">

    <div class="wrapper">

        <a class="site-title" href="/">Programming Language Foundations in Agda
</a>

        <nav class="site-nav">
            <span class="menu-icon">
                <svg viewBox="0 0 18 15" width="18px" height="15px">
                    <path fill="#424242" d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.031C17.335,0,18,0.665,18,1.484L18,1.484z"/>
                    <path fill="#424242" d="M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0c0-0.82,0.665-1.484,1.484-1.484 h15.031C17.335,6.031,18,6.696,18,7.516L18,7.516z"/>
                    <path fill="#424242" d="M18,13.516C18,14.335,17.335,15,16.516,15H1.484C0.665,15,0,14.335,0,13.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.031C17.335,12.031,18,12.696,18,13.516L18,13.516z"/>
                </svg>
            </span>

            <div class="trigger">
                <a class="page-link" href="/">Table of Contents</a>
                <a class="page-link" href="/GettingStarted/">Getting Started</a>
            </div>
        </nav>

    </div>

</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post">

  <header class="post-header">
      <h1 class="post-title">Denot: Denotational semantics for the untyped lambda calculus</h1>
  </header>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/Untyped/">Prev</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/Denot.lagda">Source</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/DenotCompositional/">Next</a>
    
</p>


  <div class="post-content">
    <pre class="Agda"><a id="191" class="Keyword">module</a> <a id="198" href="/Denot/" class="Module">plfa.Denot</a> <a id="209" class="Keyword">where</a></pre>

<p>The lambda calculus is a language about <em>functions</em>, that is, mappings
from input to output. In computing we often think of such
mappings as being carried out by a sequence of
operations that transform an input into an output.  But 
functions can also be represented as data. For example, one
can tabulate a function, that is, create a table where each row has
two entries, an input and the corresponding output for the function.
Function application is then the process of looking up the row for
a given input and reading off the output.</p>

<p>We shall create a semantics for the untyped lambda calculus based on
this idea of functions-as-tables. However, there are two difficulties
that arise. First, functions often have an infinite domain, so it
would seem that we would need infinitely long tables to represent
functions. Second, in the lambda calculus, functions can be applied to
functions. They can even be applied to themselves! So it would seem
that the tables would contain cycles. One might start to worry that
advanced techniques are necessary to to address these issues, but
fortunately this is not the case!</p>

<p>The first problem, of functions with infinite domains, is solved by
observing that in the execution of a terminating program, each lambda
abstraction will only be applied to a finite number of distinct
arguments. (We come back later to discuss diverging programs.) This
observation is another way of looking at Dana Scott’s insight that
only continuous functions are needed to model the lambda calculus.</p>

<p>The second problem, that of self-application, is solved by relaxing
the way in which we lookup an argument in a function’s table.
Naively, one would look in the table for a row in which the input
entry exactly matches the argument. In the case of self-application,
this would require the table to contain a copy of itself. Impossible!
(At least, it is impossible if we want to build tables using inductive
data type definitions, which indeed we do.)  Instead it is sufficient
to find an input such that every row of the input appears as a row of
the argument (that is, the input is a subset of the argument).  In the
case of self-application, the table only needs to contain a smaller
copy of itself, which is fine.</p>

<p>With these two observations in hand, it is straightforward to write
down a denotational semantics of the lambda calculus.</p>

<h2 id="imports">Imports</h2>

<pre class="Agda"><a id="2616" class="Keyword">open</a> <a id="2621" class="Keyword">import</a> <a id="2628" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html" class="Module">Relation.Binary.PropositionalEquality</a>
  <a id="2668" class="Keyword">using</a> <a id="2674" class="Symbol">(</a><a id="2675" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">_≡_</a><a id="2678" class="Symbol">;</a> <a id="2680" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#660" class="Function Operator">_≢_</a><a id="2683" class="Symbol">;</a> <a id="2685" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="2689" class="Symbol">;</a> <a id="2691" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.Core.html#838" class="Function">sym</a><a id="2694" class="Symbol">;</a> <a id="2696" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a><a id="2700" class="Symbol">;</a> <a id="2702" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1408" class="Function">cong₂</a><a id="2707" class="Symbol">;</a> <a id="2709" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1274" class="Function">cong-app</a><a id="2717" class="Symbol">)</a>
<a id="2719" class="Keyword">open</a> <a id="2724" class="Keyword">import</a> <a id="2731" href="https://agda.github.io/agda-stdlib/Data.Product.html" class="Module">Data.Product</a> <a id="2744" class="Keyword">using</a> <a id="2750" class="Symbol">(</a><a id="2751" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">_×_</a><a id="2754" class="Symbol">;</a> <a id="2756" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#69" class="Record">Σ</a><a id="2757" class="Symbol">;</a> <a id="2759" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">Σ-syntax</a><a id="2767" class="Symbol">;</a> <a id="2769" href="https://agda.github.io/agda-stdlib/Data.Product.html#881" class="Function">∃</a><a id="2770" class="Symbol">;</a> <a id="2772" href="https://agda.github.io/agda-stdlib/Data.Product.html#942" class="Function">∃-syntax</a><a id="2780" class="Symbol">;</a> <a id="2782" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#155" class="Field">proj₁</a><a id="2787" class="Symbol">;</a> <a id="2789" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#167" class="Field">proj₂</a><a id="2794" class="Symbol">)</a> <a id="2796" class="Keyword">renaming</a> <a id="2805" class="Symbol">(</a><a id="2806" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">_,_</a> <a id="2810" class="Symbol">to</a> <a id="2813" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨_,_⟩</a><a id="2818" class="Symbol">)</a>
<a id="2820" class="Keyword">open</a> <a id="2825" class="Keyword">import</a> <a id="2832" href="https://agda.github.io/agda-stdlib/Data.Sum.html" class="Module">Data.Sum</a>
<a id="2841" class="Keyword">open</a> <a id="2846" class="Keyword">import</a> <a id="2853" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html" class="Module">Agda.Primitive</a> <a id="2868" class="Keyword">using</a> <a id="2874" class="Symbol">(</a><a id="2875" href="https://agda.github.io/agda-stdlib/Agda.Primitive.html#611" class="Primitive">lzero</a><a id="2880" class="Symbol">)</a>
<a id="2882" class="Keyword">open</a> <a id="2887" class="Keyword">import</a> <a id="2894" href="/Untyped/" class="Module">plfa.Untyped</a>
<a id="2907" class="Keyword">open</a> <a id="2912" class="Keyword">import</a> <a id="2919" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="2936" class="Keyword">using</a> <a id="2942" class="Symbol">(</a><a id="2943" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬_</a><a id="2945" class="Symbol">)</a>
<a id="2947" class="Keyword">open</a> <a id="2952" class="Keyword">import</a> <a id="2959" href="https://agda.github.io/agda-stdlib/Relation.Nullary.Negation.html" class="Module">Relation.Nullary.Negation</a> <a id="2985" class="Keyword">using</a> <a id="2991" class="Symbol">(</a><a id="2992" href="https://agda.github.io/agda-stdlib/Relation.Nullary.Negation.html#560" class="Function">contradiction</a><a id="3005" class="Symbol">)</a>
<a id="3007" class="Keyword">open</a> <a id="3012" class="Keyword">import</a> <a id="3019" href="https://agda.github.io/agda-stdlib/Data.Empty.html" class="Module">Data.Empty</a> <a id="3030" class="Keyword">using</a> <a id="3036" class="Symbol">(</a><a id="3037" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a><a id="3043" class="Symbol">)</a>
<a id="3045" class="Keyword">open</a> <a id="3050" class="Keyword">import</a> <a id="3057" href="https://agda.github.io/agda-stdlib/Data.Unit.html" class="Module">Data.Unit</a>
<a id="3067" class="Keyword">open</a> <a id="3072" class="Keyword">import</a> <a id="3079" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html" class="Module">Relation.Nullary</a> <a id="3096" class="Keyword">using</a> <a id="3102" class="Symbol">(</a><a id="3103" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#534" class="Datatype">Dec</a><a id="3106" class="Symbol">;</a> <a id="3108" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#570" class="InductiveConstructor">yes</a><a id="3111" class="Symbol">;</a> <a id="3113" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#597" class="InductiveConstructor">no</a><a id="3115" class="Symbol">)</a>
<a id="3117" class="Keyword">open</a> <a id="3122" class="Keyword">import</a> <a id="3129" href="https://agda.github.io/agda-stdlib/Function.html" class="Module">Function</a> <a id="3138" class="Keyword">using</a> <a id="3144" class="Symbol">(</a><a id="3145" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">_∘_</a><a id="3148" class="Symbol">)</a>
<a id="3150" class="Comment">-- open import plfa.Isomorphism using (extensionality)  -- causes a bug!</a></pre>

<pre class="Agda"><a id="3248" class="Keyword">postulate</a>
  <a id="extensionality"></a><a id="3260" href="/Denot/#3260" class="Postulate">extensionality</a> <a id="3275" class="Symbol">:</a> <a id="3277" class="Symbol">∀</a> <a id="3279" class="Symbol">{</a><a id="3280" href="/Denot/#3280" class="Bound">A</a> <a id="3282" href="/Denot/#3282" class="Bound">B</a> <a id="3284" class="Symbol">:</a> <a id="3286" class="PrimitiveType">Set</a><a id="3289" class="Symbol">}</a> <a id="3291" class="Symbol">{</a><a id="3292" href="/Denot/#3292" class="Bound">f</a> <a id="3294" href="/Denot/#3294" class="Bound">g</a> <a id="3296" class="Symbol">:</a> <a id="3298" href="/Denot/#3280" class="Bound">A</a> <a id="3300" class="Symbol">→</a> <a id="3302" href="/Denot/#3282" class="Bound">B</a><a id="3303" class="Symbol">}</a>
    <a id="3309" class="Symbol">→</a> <a id="3311" class="Symbol">(∀</a> <a id="3314" class="Symbol">(</a><a id="3315" href="/Denot/#3315" class="Bound">x</a> <a id="3317" class="Symbol">:</a> <a id="3319" href="/Denot/#3280" class="Bound">A</a><a id="3320" class="Symbol">)</a> <a id="3322" class="Symbol">→</a> <a id="3324" href="/Denot/#3292" class="Bound">f</a> <a id="3326" href="/Denot/#3315" class="Bound">x</a> <a id="3328" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="3330" href="/Denot/#3294" class="Bound">g</a> <a id="3332" href="/Denot/#3315" class="Bound">x</a><a id="3333" class="Symbol">)</a>
      <a id="3341" class="Comment">-----------------------</a>
    <a id="3369" class="Symbol">→</a> <a id="3371" href="/Denot/#3292" class="Bound">f</a> <a id="3373" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="3375" href="/Denot/#3294" class="Bound">g</a></pre>

<h2 id="values">Values</h2>

<p>The <code class="highlighter-rouge">Value</code> data type represents a finite portion of a function.  We
think of a value as a finite set of pairs that represent input-output
mappings. The <code class="highlighter-rouge">Value</code> data type represents the set as a binary tree
whose internal nodes are the union operator and whose leaves represent
either a single mapping or the empty set.</p>

<ul>
  <li>
    <p>The ⊥ value provides no information about the computation.</p>
  </li>
  <li>
    <p>A value of the form <code class="highlighter-rouge">v ↦ v′</code> is a single input-output mapping, from
input <code class="highlighter-rouge">v</code> to output <code class="highlighter-rouge">v′</code>.</p>
  </li>
  <li>
    <p>A value of the form <code class="highlighter-rouge">v₁ ⊔ v₂</code> is a function that maps inputs to
outputs according to both <code class="highlighter-rouge">v₁</code> and <code class="highlighter-rouge">v₂</code>.  Think of it as taking the
union of the two sets.</p>
  </li>
</ul>

<pre class="Agda"><a id="4069" class="Keyword">infixr</a> <a id="4076" class="Number">7</a> <a id="4078" href="/Denot/#4133" class="InductiveConstructor Operator">_↦_</a>
<a id="4082" class="Keyword">infixl</a> <a id="4089" class="Number">5</a> <a id="4091" href="/Denot/#4163" class="InductiveConstructor Operator">_⊔_</a>

<a id="4096" class="Keyword">data</a> <a id="Value"></a><a id="4101" href="/Denot/#4101" class="Datatype">Value</a> <a id="4107" class="Symbol">:</a> <a id="4109" class="PrimitiveType">Set</a> <a id="4113" class="Keyword">where</a>
  <a id="Value.⊥"></a><a id="4121" href="/Denot/#4121" class="InductiveConstructor">⊥</a> <a id="4123" class="Symbol">:</a> <a id="4125" href="/Denot/#4101" class="Datatype">Value</a>
  <a id="Value._↦_"></a><a id="4133" href="/Denot/#4133" class="InductiveConstructor Operator">_↦_</a> <a id="4137" class="Symbol">:</a> <a id="4139" href="/Denot/#4101" class="Datatype">Value</a> <a id="4145" class="Symbol">→</a> <a id="4147" href="/Denot/#4101" class="Datatype">Value</a> <a id="4153" class="Symbol">→</a> <a id="4155" href="/Denot/#4101" class="Datatype">Value</a>
  <a id="Value._⊔_"></a><a id="4163" href="/Denot/#4163" class="InductiveConstructor Operator">_⊔_</a> <a id="4167" class="Symbol">:</a> <a id="4169" href="/Denot/#4101" class="Datatype">Value</a> <a id="4175" class="Symbol">→</a> <a id="4177" href="/Denot/#4101" class="Datatype">Value</a> <a id="4183" class="Symbol">→</a> <a id="4185" href="/Denot/#4101" class="Datatype">Value</a></pre>

<p>The ⊑ relation adapts the familiar notion of subset to the Value data
type. This relation plays the key role in enabling self-application.
There are two rules that are specific to functions, Fun⊑ and Dist⊑,
which we discuss below.</p>

<pre class="Agda"><a id="4448" class="Keyword">infix</a> <a id="4454" class="Number">4</a> <a id="4456" href="/Denot/#4466" class="Datatype Operator">_⊑_</a>

<a id="4461" class="Keyword">data</a> <a id="_⊑_"></a><a id="4466" href="/Denot/#4466" class="Datatype Operator">_⊑_</a> <a id="4470" class="Symbol">:</a> <a id="4472" href="/Denot/#4101" class="Datatype">Value</a> <a id="4478" class="Symbol">→</a> <a id="4480" href="/Denot/#4101" class="Datatype">Value</a> <a id="4486" class="Symbol">→</a> <a id="4488" class="PrimitiveType">Set</a> <a id="4492" class="Keyword">where</a>

  <a id="_⊑_.Bot⊑"></a><a id="4501" href="/Denot/#4501" class="InductiveConstructor">Bot⊑</a> <a id="4506" class="Symbol">:</a> <a id="4508" class="Symbol">∀</a> <a id="4510" class="Symbol">{</a><a id="4511" href="/Denot/#4511" class="Bound">v</a><a id="4512" class="Symbol">}</a> <a id="4514" class="Symbol">→</a> <a id="4516" href="/Denot/#4121" class="InductiveConstructor">⊥</a> <a id="4518" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4520" href="/Denot/#4511" class="Bound">v</a>

  <a id="_⊑_.ConjL⊑"></a><a id="4525" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="4532" class="Symbol">:</a> <a id="4534" class="Symbol">∀</a> <a id="4536" class="Symbol">{</a><a id="4537" href="/Denot/#4537" class="Bound">v</a> <a id="4539" href="/Denot/#4539" class="Bound">v₁</a> <a id="4542" href="/Denot/#4542" class="Bound">v₂</a><a id="4544" class="Symbol">}</a>
      <a id="4552" class="Symbol">→</a> <a id="4554" href="/Denot/#4539" class="Bound">v₁</a> <a id="4557" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4559" href="/Denot/#4537" class="Bound">v</a>
      <a id="4567" class="Symbol">→</a> <a id="4569" href="/Denot/#4542" class="Bound">v₂</a> <a id="4572" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4574" href="/Denot/#4537" class="Bound">v</a>
        <a id="4584" class="Comment">-----------------</a>
      <a id="4608" class="Symbol">→</a> <a id="4610" class="Symbol">(</a><a id="4611" href="/Denot/#4539" class="Bound">v₁</a> <a id="4614" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="4616" href="/Denot/#4542" class="Bound">v₂</a><a id="4618" class="Symbol">)</a> <a id="4620" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4622" href="/Denot/#4537" class="Bound">v</a>

  <a id="_⊑_.ConjR1⊑"></a><a id="4627" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="4635" class="Symbol">:</a> <a id="4637" class="Symbol">∀</a> <a id="4639" class="Symbol">{</a><a id="4640" href="/Denot/#4640" class="Bound">v</a> <a id="4642" href="/Denot/#4642" class="Bound">v₁</a> <a id="4645" href="/Denot/#4645" class="Bound">v₂</a><a id="4647" class="Symbol">}</a>
     <a id="4654" class="Symbol">→</a> <a id="4656" href="/Denot/#4640" class="Bound">v</a> <a id="4658" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4660" href="/Denot/#4642" class="Bound">v₁</a>
       <a id="4670" class="Comment">-------------</a>
     <a id="4689" class="Symbol">→</a> <a id="4691" href="/Denot/#4640" class="Bound">v</a> <a id="4693" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4695" class="Symbol">(</a><a id="4696" href="/Denot/#4642" class="Bound">v₁</a> <a id="4699" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="4701" href="/Denot/#4645" class="Bound">v₂</a><a id="4703" class="Symbol">)</a>

  <a id="_⊑_.ConjR2⊑"></a><a id="4708" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="4716" class="Symbol">:</a> <a id="4718" class="Symbol">∀</a> <a id="4720" class="Symbol">{</a><a id="4721" href="/Denot/#4721" class="Bound">v</a> <a id="4723" href="/Denot/#4723" class="Bound">v₁</a> <a id="4726" href="/Denot/#4726" class="Bound">v₂</a><a id="4728" class="Symbol">}</a>
     <a id="4735" class="Symbol">→</a> <a id="4737" href="/Denot/#4721" class="Bound">v</a> <a id="4739" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4741" href="/Denot/#4726" class="Bound">v₂</a>
       <a id="4751" class="Comment">-------------</a>
     <a id="4770" class="Symbol">→</a> <a id="4772" href="/Denot/#4721" class="Bound">v</a> <a id="4774" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4776" class="Symbol">(</a><a id="4777" href="/Denot/#4723" class="Bound">v₁</a> <a id="4780" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="4782" href="/Denot/#4726" class="Bound">v₂</a><a id="4784" class="Symbol">)</a>

  <a id="_⊑_.Trans⊑"></a><a id="4789" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="4796" class="Symbol">:</a> <a id="4798" class="Symbol">∀</a> <a id="4800" class="Symbol">{</a><a id="4801" href="/Denot/#4801" class="Bound">v₁</a> <a id="4804" href="/Denot/#4804" class="Bound">v₂</a> <a id="4807" href="/Denot/#4807" class="Bound">v₃</a><a id="4809" class="Symbol">}</a>
     <a id="4816" class="Symbol">→</a> <a id="4818" href="/Denot/#4801" class="Bound">v₁</a> <a id="4821" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4823" href="/Denot/#4804" class="Bound">v₂</a>
     <a id="4831" class="Symbol">→</a> <a id="4833" href="/Denot/#4804" class="Bound">v₂</a> <a id="4836" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4838" href="/Denot/#4807" class="Bound">v₃</a>
       <a id="4848" class="Comment">--------</a>
     <a id="4862" class="Symbol">→</a> <a id="4864" href="/Denot/#4801" class="Bound">v₁</a> <a id="4867" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4869" href="/Denot/#4807" class="Bound">v₃</a>

  <a id="_⊑_.Fun⊑"></a><a id="4875" href="/Denot/#4875" class="InductiveConstructor">Fun⊑</a> <a id="4880" class="Symbol">:</a> <a id="4882" class="Symbol">∀</a> <a id="4884" class="Symbol">{</a><a id="4885" href="/Denot/#4885" class="Bound">v₁</a> <a id="4888" href="/Denot/#4888" class="Bound">v₂</a> <a id="4891" href="/Denot/#4891" class="Bound">v₃</a> <a id="4894" href="/Denot/#4894" class="Bound">v₄</a><a id="4896" class="Symbol">}</a>
       <a id="4905" class="Symbol">→</a> <a id="4907" href="/Denot/#4891" class="Bound">v₃</a> <a id="4910" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4912" href="/Denot/#4885" class="Bound">v₁</a>
       <a id="4922" class="Symbol">→</a> <a id="4924" href="/Denot/#4888" class="Bound">v₂</a> <a id="4927" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4929" href="/Denot/#4894" class="Bound">v₄</a>
         <a id="4941" class="Comment">---------------------</a>
       <a id="4970" class="Symbol">→</a> <a id="4972" class="Symbol">(</a><a id="4973" href="/Denot/#4885" class="Bound">v₁</a> <a id="4976" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="4978" href="/Denot/#4888" class="Bound">v₂</a><a id="4980" class="Symbol">)</a> <a id="4982" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="4984" class="Symbol">(</a><a id="4985" href="/Denot/#4891" class="Bound">v₃</a> <a id="4988" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="4990" href="/Denot/#4894" class="Bound">v₄</a><a id="4992" class="Symbol">)</a>

  <a id="_⊑_.Dist⊑"></a><a id="4997" href="/Denot/#4997" class="InductiveConstructor">Dist⊑</a> <a id="5003" class="Symbol">:</a> <a id="5005" class="Symbol">∀{</a><a id="5007" href="/Denot/#5007" class="Bound">v₁</a> <a id="5010" href="/Denot/#5010" class="Bound">v₂</a> <a id="5013" href="/Denot/#5013" class="Bound">v₃</a><a id="5015" class="Symbol">}</a>
         <a id="5026" class="Comment">--------------------------------------</a>
       <a id="5072" class="Symbol">→</a> <a id="5074" href="/Denot/#5007" class="Bound">v₁</a> <a id="5077" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="5079" class="Symbol">(</a><a id="5080" href="/Denot/#5010" class="Bound">v₂</a> <a id="5083" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="5085" href="/Denot/#5013" class="Bound">v₃</a><a id="5087" class="Symbol">)</a> <a id="5089" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="5091" class="Symbol">(</a><a id="5092" href="/Denot/#5007" class="Bound">v₁</a> <a id="5095" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="5097" href="/Denot/#5010" class="Bound">v₂</a><a id="5099" class="Symbol">)</a> <a id="5101" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="5103" class="Symbol">(</a><a id="5104" href="/Denot/#5007" class="Bound">v₁</a> <a id="5107" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="5109" href="/Denot/#5013" class="Bound">v₃</a><a id="5111" class="Symbol">)</a></pre>

<p>The first five rules are straightforward.
The rule <code class="highlighter-rouge">Fun⊑</code> captures when it is OK to match a higher-order argument
<code class="highlighter-rouge">v₃ ↦ v₄</code> to a table entry whose input is <code class="highlighter-rouge">v₁ ↦ v₂</code>.  Considering a
call to the higher-order argument. It is OK to pass a larger argument
than expected, so <code class="highlighter-rouge">v₁</code> can be larger than <code class="highlighter-rouge">v₃</code>. Also, it is OK to
disregard some of the output, so <code class="highlighter-rouge">v₂</code> can be smaller than <code class="highlighter-rouge">v₄</code>.
The rule <code class="highlighter-rouge">Dist⊑</code> says that if you have two entries for the same input,
then you can combine them into a single entry and joins the two
outputs.</p>

<p>The <code class="highlighter-rouge">⊑</code> relation is reflexive.</p>

<pre class="Agda"><a id="Refl⊑"></a><a id="5698" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="5704" class="Symbol">:</a> <a id="5706" class="Symbol">∀</a> <a id="5708" class="Symbol">{</a><a id="5709" href="/Denot/#5709" class="Bound">v</a><a id="5710" class="Symbol">}</a> <a id="5712" class="Symbol">→</a> <a id="5714" href="/Denot/#5709" class="Bound">v</a> <a id="5716" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="5718" href="/Denot/#5709" class="Bound">v</a>
<a id="5720" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="5726" class="Symbol">{</a><a id="5727" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="5728" class="Symbol">}</a> <a id="5730" class="Symbol">=</a> <a id="5732" href="/Denot/#4501" class="InductiveConstructor">Bot⊑</a>
<a id="5737" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="5743" class="Symbol">{</a><a id="5744" href="/Denot/#5744" class="Bound">v</a> <a id="5746" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="5748" href="/Denot/#5748" class="Bound">v&#39;</a><a id="5750" class="Symbol">}</a> <a id="5752" class="Symbol">=</a> <a id="5754" href="/Denot/#4875" class="InductiveConstructor">Fun⊑</a> <a id="5759" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="5765" href="/Denot/#5698" class="Function">Refl⊑</a>
<a id="5771" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="5777" class="Symbol">{</a><a id="5778" href="/Denot/#5778" class="Bound">v₁</a> <a id="5781" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="5783" href="/Denot/#5783" class="Bound">v₂</a><a id="5785" class="Symbol">}</a> <a id="5787" class="Symbol">=</a> <a id="5789" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="5796" class="Symbol">(</a><a id="5797" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="5805" href="/Denot/#5698" class="Function">Refl⊑</a><a id="5810" class="Symbol">)</a> <a id="5812" class="Symbol">(</a><a id="5813" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="5821" href="/Denot/#5698" class="Function">Refl⊑</a><a id="5826" class="Symbol">)</a></pre>

<p>The <code class="highlighter-rouge">⊔</code> operation is monotonic with respect to <code class="highlighter-rouge">⊑</code>, that is, given two
larger values it produces a larger value.</p>

<pre class="Agda"><a id="⊔⊑⊔"></a><a id="5967" href="/Denot/#5967" class="Function">⊔⊑⊔</a> <a id="5971" class="Symbol">:</a> <a id="5973" class="Symbol">∀</a> <a id="5975" class="Symbol">{</a><a id="5976" href="/Denot/#5976" class="Bound">v₁</a> <a id="5979" href="/Denot/#5979" class="Bound">v₂</a> <a id="5982" href="/Denot/#5982" class="Bound">v₃</a> <a id="5985" href="/Denot/#5985" class="Bound">v₄</a><a id="5987" class="Symbol">}</a>
      <a id="5995" class="Symbol">→</a> <a id="5997" href="/Denot/#5976" class="Bound">v₁</a> <a id="6000" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="6002" href="/Denot/#5982" class="Bound">v₃</a>  <a id="6006" class="Symbol">→</a>  <a id="6009" href="/Denot/#5979" class="Bound">v₂</a> <a id="6012" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="6014" href="/Denot/#5985" class="Bound">v₄</a>
        <a id="6025" class="Comment">-----------------------</a>
      <a id="6055" class="Symbol">→</a> <a id="6057" class="Symbol">(</a><a id="6058" href="/Denot/#5976" class="Bound">v₁</a> <a id="6061" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="6063" href="/Denot/#5979" class="Bound">v₂</a><a id="6065" class="Symbol">)</a> <a id="6067" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="6069" class="Symbol">(</a><a id="6070" href="/Denot/#5982" class="Bound">v₃</a> <a id="6073" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="6075" href="/Denot/#5985" class="Bound">v₄</a><a id="6077" class="Symbol">)</a>
<a id="6079" href="/Denot/#5967" class="Function">⊔⊑⊔</a> <a id="6083" href="/Denot/#6083" class="Bound">d₁</a> <a id="6086" href="/Denot/#6086" class="Bound">d₂</a> <a id="6089" class="Symbol">=</a> <a id="6091" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="6098" class="Symbol">(</a><a id="6099" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="6107" href="/Denot/#6083" class="Bound">d₁</a><a id="6109" class="Symbol">)</a> <a id="6111" class="Symbol">(</a><a id="6112" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="6120" href="/Denot/#6086" class="Bound">d₂</a><a id="6122" class="Symbol">)</a></pre>

<p>The (Dist⊑) rule can be used to combine two entries even when the
input values are not identical. One can first combine the two inputs
using ⊔ and then apply the (Dist⊑) rule to obtain the following
property.</p>

<pre class="Agda"><a id="Dist⊔↦⊔"></a><a id="6359" href="/Denot/#6359" class="Function">Dist⊔↦⊔</a> <a id="6367" class="Symbol">:</a> <a id="6369" class="Symbol">∀{</a><a id="6371" href="/Denot/#6371" class="Bound">v₁</a> <a id="6374" href="/Denot/#6374" class="Bound">v₁&#39;</a> <a id="6378" href="/Denot/#6378" class="Bound">v₂</a> <a id="6381" href="/Denot/#6381" class="Bound">v₂&#39;</a> <a id="6385" class="Symbol">:</a> <a id="6387" href="/Denot/#4101" class="Datatype">Value</a><a id="6392" class="Symbol">}</a>
        <a id="6402" class="Symbol">→</a> <a id="6404" class="Symbol">(</a><a id="6405" href="/Denot/#6371" class="Bound">v₁</a> <a id="6408" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="6410" href="/Denot/#6374" class="Bound">v₁&#39;</a><a id="6413" class="Symbol">)</a> <a id="6415" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="6417" class="Symbol">(</a><a id="6418" href="/Denot/#6378" class="Bound">v₂</a> <a id="6421" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="6423" href="/Denot/#6381" class="Bound">v₂&#39;</a><a id="6426" class="Symbol">)</a> <a id="6428" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="6430" class="Symbol">(</a><a id="6431" href="/Denot/#6371" class="Bound">v₁</a> <a id="6434" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="6436" href="/Denot/#6378" class="Bound">v₂</a><a id="6438" class="Symbol">)</a> <a id="6440" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="6442" class="Symbol">(</a><a id="6443" href="/Denot/#6374" class="Bound">v₁&#39;</a> <a id="6447" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="6449" href="/Denot/#6381" class="Bound">v₂&#39;</a><a id="6452" class="Symbol">)</a>
<a id="6454" href="/Denot/#6359" class="Function">Dist⊔↦⊔</a><a id="6461" class="Symbol">{</a><a id="6462" href="/Denot/#6462" class="Bound">v₁</a><a id="6464" class="Symbol">}{</a><a id="6466" href="/Denot/#6466" class="Bound">v₁&#39;</a><a id="6469" class="Symbol">}{</a><a id="6471" href="/Denot/#6471" class="Bound">v₂</a><a id="6473" class="Symbol">}{</a><a id="6475" href="/Denot/#6475" class="Bound">v₂&#39;</a><a id="6478" class="Symbol">}</a> <a id="6480" class="Symbol">=</a>
    <a id="6486" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="6493" class="Symbol">(</a><a id="6494" href="/Denot/#4997" class="InductiveConstructor">Dist⊑</a> <a id="6500" class="Symbol">{</a><a id="6501" class="Argument">v₁</a> <a id="6504" class="Symbol">=</a> <a id="6506" href="/Denot/#6462" class="Bound">v₁</a> <a id="6509" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="6511" href="/Denot/#6466" class="Bound">v₁&#39;</a><a id="6514" class="Symbol">}{</a><a id="6516" class="Argument">v₂</a> <a id="6519" class="Symbol">=</a> <a id="6521" href="/Denot/#6471" class="Bound">v₂</a><a id="6523" class="Symbol">}{</a><a id="6525" class="Argument">v₃</a> <a id="6528" class="Symbol">=</a> <a id="6530" href="/Denot/#6475" class="Bound">v₂&#39;</a><a id="6533" class="Symbol">})</a>
           <a id="6547" class="Symbol">(</a><a id="6548" href="/Denot/#5967" class="Function">⊔⊑⊔</a> <a id="6552" class="Symbol">(</a><a id="6553" href="/Denot/#4875" class="InductiveConstructor">Fun⊑</a> <a id="6558" class="Symbol">(</a><a id="6559" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="6567" href="/Denot/#5698" class="Function">Refl⊑</a><a id="6572" class="Symbol">)</a> <a id="6574" href="/Denot/#5698" class="Function">Refl⊑</a><a id="6579" class="Symbol">)</a>
                      <a id="6603" class="Symbol">(</a><a id="6604" href="/Denot/#4875" class="InductiveConstructor">Fun⊑</a> <a id="6609" class="Symbol">(</a><a id="6610" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="6618" href="/Denot/#5698" class="Function">Refl⊑</a><a id="6623" class="Symbol">)</a> <a id="6625" href="/Denot/#5698" class="Function">Refl⊑</a><a id="6630" class="Symbol">))</a></pre>

<!-- above might read more nicely if we introduce inequational reasoning -->

<p>If the join v₁ ⊔ v₂ is less than another value v₃,
then both v₁ and v₂ are less than v₃.</p>

<pre class="Agda"><a id="⊔⊑-invL"></a><a id="6826" href="/Denot/#6826" class="Function">⊔⊑-invL</a> <a id="6834" class="Symbol">:</a> <a id="6836" class="Symbol">∀{</a><a id="6838" href="/Denot/#6838" class="Bound">v₁</a> <a id="6841" href="/Denot/#6841" class="Bound">v₂</a> <a id="6844" href="/Denot/#6844" class="Bound">v₃</a> <a id="6847" class="Symbol">:</a> <a id="6849" href="/Denot/#4101" class="Datatype">Value</a><a id="6854" class="Symbol">}</a>
        <a id="6864" class="Symbol">→</a> <a id="6866" href="/Denot/#6838" class="Bound">v₁</a> <a id="6869" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="6871" href="/Denot/#6841" class="Bound">v₂</a> <a id="6874" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="6876" href="/Denot/#6844" class="Bound">v₃</a>
          <a id="6889" class="Comment">------------</a>
        <a id="6910" class="Symbol">→</a> <a id="6912" href="/Denot/#6838" class="Bound">v₁</a> <a id="6915" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="6917" href="/Denot/#6844" class="Bound">v₃</a>
<a id="6920" href="/Denot/#6826" class="Function">⊔⊑-invL</a> <a id="6928" class="Symbol">(</a><a id="6929" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="6936" href="/Denot/#6936" class="Bound">lt1</a> <a id="6940" href="/Denot/#6940" class="Bound">lt2</a><a id="6943" class="Symbol">)</a> <a id="6945" class="Symbol">=</a> <a id="6947" href="/Denot/#6936" class="Bound">lt1</a>
<a id="6951" href="/Denot/#6826" class="Function">⊔⊑-invL</a> <a id="6959" class="Symbol">(</a><a id="6960" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="6968" href="/Denot/#6968" class="Bound">lt</a><a id="6970" class="Symbol">)</a> <a id="6972" class="Symbol">=</a> <a id="6974" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="6982" class="Symbol">(</a><a id="6983" href="/Denot/#6826" class="Function">⊔⊑-invL</a> <a id="6991" href="/Denot/#6968" class="Bound">lt</a><a id="6993" class="Symbol">)</a>
<a id="6995" href="/Denot/#6826" class="Function">⊔⊑-invL</a> <a id="7003" class="Symbol">(</a><a id="7004" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="7012" href="/Denot/#7012" class="Bound">lt</a><a id="7014" class="Symbol">)</a> <a id="7016" class="Symbol">=</a> <a id="7018" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="7026" class="Symbol">(</a><a id="7027" href="/Denot/#6826" class="Function">⊔⊑-invL</a> <a id="7035" href="/Denot/#7012" class="Bound">lt</a><a id="7037" class="Symbol">)</a>
<a id="7039" href="/Denot/#6826" class="Function">⊔⊑-invL</a> <a id="7047" class="Symbol">(</a><a id="7048" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="7055" href="/Denot/#7055" class="Bound">lt1</a> <a id="7059" href="/Denot/#7059" class="Bound">lt2</a><a id="7062" class="Symbol">)</a> <a id="7064" class="Symbol">=</a> <a id="7066" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="7073" class="Symbol">(</a><a id="7074" href="/Denot/#6826" class="Function">⊔⊑-invL</a> <a id="7082" href="/Denot/#7055" class="Bound">lt1</a><a id="7085" class="Symbol">)</a> <a id="7087" href="/Denot/#7059" class="Bound">lt2</a>

<a id="⊔⊑-invR"></a><a id="7092" href="/Denot/#7092" class="Function">⊔⊑-invR</a> <a id="7100" class="Symbol">:</a> <a id="7102" class="Symbol">∀{</a><a id="7104" href="/Denot/#7104" class="Bound">v₁</a> <a id="7107" href="/Denot/#7107" class="Bound">v₂</a> <a id="7110" href="/Denot/#7110" class="Bound">v₃</a> <a id="7113" class="Symbol">:</a> <a id="7115" href="/Denot/#4101" class="Datatype">Value</a><a id="7120" class="Symbol">}</a>
       <a id="7129" class="Symbol">→</a> <a id="7131" href="/Denot/#7104" class="Bound">v₁</a> <a id="7134" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="7136" href="/Denot/#7107" class="Bound">v₂</a> <a id="7139" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="7141" href="/Denot/#7110" class="Bound">v₃</a>
         <a id="7153" class="Comment">------------</a>
       <a id="7173" class="Symbol">→</a> <a id="7175" href="/Denot/#7107" class="Bound">v₂</a> <a id="7178" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="7180" href="/Denot/#7110" class="Bound">v₃</a>
<a id="7183" href="/Denot/#7092" class="Function">⊔⊑-invR</a> <a id="7191" class="Symbol">(</a><a id="7192" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="7199" href="/Denot/#7199" class="Bound">lt</a> <a id="7202" href="/Denot/#7202" class="Bound">lt₁</a><a id="7205" class="Symbol">)</a> <a id="7207" class="Symbol">=</a> <a id="7209" href="/Denot/#7202" class="Bound">lt₁</a>
<a id="7213" href="/Denot/#7092" class="Function">⊔⊑-invR</a> <a id="7221" class="Symbol">(</a><a id="7222" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="7230" href="/Denot/#7230" class="Bound">lt</a><a id="7232" class="Symbol">)</a> <a id="7234" class="Symbol">=</a> <a id="7236" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="7244" class="Symbol">(</a><a id="7245" href="/Denot/#7092" class="Function">⊔⊑-invR</a> <a id="7253" href="/Denot/#7230" class="Bound">lt</a><a id="7255" class="Symbol">)</a>
<a id="7257" href="/Denot/#7092" class="Function">⊔⊑-invR</a> <a id="7265" class="Symbol">(</a><a id="7266" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="7274" href="/Denot/#7274" class="Bound">lt</a><a id="7276" class="Symbol">)</a> <a id="7278" class="Symbol">=</a> <a id="7280" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="7288" class="Symbol">(</a><a id="7289" href="/Denot/#7092" class="Function">⊔⊑-invR</a> <a id="7297" href="/Denot/#7274" class="Bound">lt</a><a id="7299" class="Symbol">)</a>
<a id="7301" href="/Denot/#7092" class="Function">⊔⊑-invR</a> <a id="7309" class="Symbol">(</a><a id="7310" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="7317" href="/Denot/#7317" class="Bound">lt</a> <a id="7320" href="/Denot/#7320" class="Bound">lt₁</a><a id="7323" class="Symbol">)</a> <a id="7325" class="Symbol">=</a> <a id="7327" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="7334" class="Symbol">(</a><a id="7335" href="/Denot/#7092" class="Function">⊔⊑-invR</a> <a id="7343" href="/Denot/#7317" class="Bound">lt</a><a id="7345" class="Symbol">)</a> <a id="7347" href="/Denot/#7320" class="Bound">lt₁</a></pre>

<h2 id="environments">Environments</h2>

<p>An environment gives meaning to the free variables in a term by
mapping variables to values.</p>

<pre class="Agda"><a id="Env"></a><a id="7488" href="/Denot/#7488" class="Function">Env</a> <a id="7492" class="Symbol">:</a> <a id="7494" href="/Untyped/#2980" class="Datatype">Context</a> <a id="7502" class="Symbol">→</a> <a id="7504" class="PrimitiveType">Set</a>
<a id="7508" href="/Denot/#7488" class="Function">Env</a> <a id="7512" href="/Denot/#7512" class="Bound">Γ</a> <a id="7514" class="Symbol">=</a> <a id="7516" class="Symbol">∀</a> <a id="7518" class="Symbol">(</a><a id="7519" href="/Denot/#7519" class="Bound">x</a> <a id="7521" class="Symbol">:</a> <a id="7523" href="/Denot/#7512" class="Bound">Γ</a> <a id="7525" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="7527" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="7528" class="Symbol">)</a> <a id="7530" class="Symbol">→</a> <a id="7532" href="/Denot/#4101" class="Datatype">Value</a></pre>

<p>We have the empty environment, and we can extend an environment.</p>
<pre class="Agda"><a id="`∅"></a><a id="7628" href="/Denot/#7628" class="Function">`∅</a> <a id="7631" class="Symbol">:</a> <a id="7633" href="/Denot/#7488" class="Function">Env</a> <a id="7637" href="/Untyped/#3002" class="InductiveConstructor">∅</a>
<a id="7639" href="/Denot/#7628" class="Function">`∅</a> <a id="7642" class="Symbol">()</a>

<a id="_`,_"></a><a id="7646" href="/Denot/#7646" class="Function Operator">_`,_</a> <a id="7651" class="Symbol">:</a> <a id="7653" class="Symbol">∀</a> <a id="7655" class="Symbol">{</a><a id="7656" href="/Denot/#7656" class="Bound">Γ</a><a id="7657" class="Symbol">}</a> <a id="7659" class="Symbol">→</a> <a id="7661" href="/Denot/#7488" class="Function">Env</a> <a id="7665" href="/Denot/#7656" class="Bound">Γ</a> <a id="7667" class="Symbol">→</a> <a id="7669" href="/Denot/#4101" class="Datatype">Value</a> <a id="7675" class="Symbol">→</a> <a id="7677" href="/Denot/#7488" class="Function">Env</a> <a id="7681" class="Symbol">(</a><a id="7682" href="/Denot/#7656" class="Bound">Γ</a> <a id="7684" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="7686" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="7687" class="Symbol">)</a>
<a id="7689" class="Symbol">(</a><a id="7690" href="/Denot/#7690" class="Bound">γ</a> <a id="7692" href="/Denot/#7646" class="Function Operator">`,</a> <a id="7695" href="/Denot/#7695" class="Bound">v</a><a id="7696" class="Symbol">)</a> <a id="7698" href="/Untyped/#3401" class="InductiveConstructor">Z</a> <a id="7700" class="Symbol">=</a> <a id="7702" href="/Denot/#7695" class="Bound">v</a>
<a id="7704" class="Symbol">(</a><a id="7705" href="/Denot/#7705" class="Bound">γ</a> <a id="7707" href="/Denot/#7646" class="Function Operator">`,</a> <a id="7710" href="/Denot/#7710" class="Bound">v</a><a id="7711" class="Symbol">)</a> <a id="7713" class="Symbol">(</a><a id="7714" href="/Untyped/#3446" class="InductiveConstructor Operator">S</a> <a id="7716" href="/Denot/#7716" class="Bound">x</a><a id="7717" class="Symbol">)</a> <a id="7719" class="Symbol">=</a> <a id="7721" href="/Denot/#7705" class="Bound">γ</a> <a id="7723" href="/Denot/#7716" class="Bound">x</a></pre>

<p>We can recover the initial environment from an extended environment,
and the last value. Putting them back together again takes us where we started.</p>
<pre class="Agda"><a id="init"></a><a id="7899" href="/Denot/#7899" class="Function">init</a> <a id="7904" class="Symbol">:</a> <a id="7906" class="Symbol">∀</a> <a id="7908" class="Symbol">{</a><a id="7909" href="/Denot/#7909" class="Bound">Γ</a><a id="7910" class="Symbol">}</a> <a id="7912" class="Symbol">→</a> <a id="7914" href="/Denot/#7488" class="Function">Env</a> <a id="7918" class="Symbol">(</a><a id="7919" href="/Denot/#7909" class="Bound">Γ</a> <a id="7921" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="7923" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="7924" class="Symbol">)</a> <a id="7926" class="Symbol">→</a> <a id="7928" href="/Denot/#7488" class="Function">Env</a> <a id="7932" href="/Denot/#7909" class="Bound">Γ</a>
<a id="7934" href="/Denot/#7899" class="Function">init</a> <a id="7939" href="/Denot/#7939" class="Bound">γ</a> <a id="7941" href="/Denot/#7941" class="Bound">x</a> <a id="7943" class="Symbol">=</a> <a id="7945" href="/Denot/#7939" class="Bound">γ</a> <a id="7947" class="Symbol">(</a><a id="7948" href="/Untyped/#3446" class="InductiveConstructor Operator">S</a> <a id="7950" href="/Denot/#7941" class="Bound">x</a><a id="7951" class="Symbol">)</a>

<a id="last"></a><a id="7954" href="/Denot/#7954" class="Function">last</a> <a id="7959" class="Symbol">:</a> <a id="7961" class="Symbol">∀</a> <a id="7963" class="Symbol">{</a><a id="7964" href="/Denot/#7964" class="Bound">Γ</a><a id="7965" class="Symbol">}</a> <a id="7967" class="Symbol">→</a> <a id="7969" href="/Denot/#7488" class="Function">Env</a> <a id="7973" class="Symbol">(</a><a id="7974" href="/Denot/#7964" class="Bound">Γ</a> <a id="7976" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="7978" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="7979" class="Symbol">)</a> <a id="7981" class="Symbol">→</a> <a id="7983" href="/Denot/#4101" class="Datatype">Value</a>
<a id="7989" href="/Denot/#7954" class="Function">last</a> <a id="7994" href="/Denot/#7994" class="Bound">γ</a> <a id="7996" class="Symbol">=</a> <a id="7998" href="/Denot/#7994" class="Bound">γ</a> <a id="8000" href="/Untyped/#3401" class="InductiveConstructor">Z</a>

<a id="init-last"></a><a id="8003" href="/Denot/#8003" class="Function">init-last</a> <a id="8013" class="Symbol">:</a> <a id="8015" class="Symbol">∀</a> <a id="8017" class="Symbol">{</a><a id="8018" href="/Denot/#8018" class="Bound">Γ</a><a id="8019" class="Symbol">}</a> <a id="8021" class="Symbol">→</a> <a id="8023" class="Symbol">(</a><a id="8024" href="/Denot/#8024" class="Bound">γ</a> <a id="8026" class="Symbol">:</a> <a id="8028" href="/Denot/#7488" class="Function">Env</a> <a id="8032" class="Symbol">(</a><a id="8033" href="/Denot/#8018" class="Bound">Γ</a> <a id="8035" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="8037" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="8038" class="Symbol">))</a> <a id="8041" class="Symbol">→</a> <a id="8043" href="/Denot/#8024" class="Bound">γ</a> <a id="8045" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="8047" class="Symbol">(</a><a id="8048" href="/Denot/#7899" class="Function">init</a> <a id="8053" href="/Denot/#8024" class="Bound">γ</a> <a id="8055" href="/Denot/#7646" class="Function Operator">`,</a> <a id="8058" href="/Denot/#7954" class="Function">last</a> <a id="8063" href="/Denot/#8024" class="Bound">γ</a><a id="8064" class="Symbol">)</a>
<a id="8066" href="/Denot/#8003" class="Function">init-last</a> <a id="8076" class="Symbol">{</a><a id="8077" href="/Denot/#8077" class="Bound">Γ</a><a id="8078" class="Symbol">}</a> <a id="8080" href="/Denot/#8080" class="Bound">γ</a> <a id="8082" class="Symbol">=</a> <a id="8084" href="/Denot/#3260" class="Postulate">extensionality</a> <a id="8099" href="/Denot/#8115" class="Function">lemma</a>
  <a id="8107" class="Keyword">where</a>
  <a id="8115" href="/Denot/#8115" class="Function">lemma</a> <a id="8121" class="Symbol">:</a> <a id="8123" class="Symbol">∀</a> <a id="8125" class="Symbol">(</a><a id="8126" href="/Denot/#8126" class="Bound">x</a> <a id="8128" class="Symbol">:</a> <a id="8130" href="/Denot/#8077" class="Bound">Γ</a> <a id="8132" href="/Untyped/#3018" class="InductiveConstructor Operator">,</a> <a id="8134" href="/Untyped/#2694" class="InductiveConstructor">★</a> <a id="8136" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="8138" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="8139" class="Symbol">)</a> <a id="8141" class="Symbol">→</a> <a id="8143" href="/Denot/#8080" class="Bound">γ</a> <a id="8145" href="/Denot/#8126" class="Bound">x</a> <a id="8147" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="8149" class="Symbol">(</a><a id="8150" href="/Denot/#7899" class="Function">init</a> <a id="8155" href="/Denot/#8080" class="Bound">γ</a> <a id="8157" href="/Denot/#7646" class="Function Operator">`,</a> <a id="8160" href="/Denot/#7954" class="Function">last</a> <a id="8165" href="/Denot/#8080" class="Bound">γ</a><a id="8166" class="Symbol">)</a> <a id="8168" href="/Denot/#8126" class="Bound">x</a>
  <a id="8172" href="/Denot/#8115" class="Function">lemma</a> <a id="8178" href="/Untyped/#3401" class="InductiveConstructor">Z</a>      <a id="8185" class="Symbol">=</a>  <a id="8188" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
  <a id="8195" href="/Denot/#8115" class="Function">lemma</a> <a id="8201" class="Symbol">(</a><a id="8202" href="/Untyped/#3446" class="InductiveConstructor Operator">S</a> <a id="8204" href="/Denot/#8204" class="Bound">x</a><a id="8205" class="Symbol">)</a>  <a id="8208" class="Symbol">=</a>  <a id="8211" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>The nth function takes a De Bruijn index and finds the corresponding
value in the environment.</p>

<pre class="Agda"><a id="nth"></a><a id="8337" href="/Denot/#8337" class="Function">nth</a> <a id="8341" class="Symbol">:</a> <a id="8343" class="Symbol">∀{</a><a id="8345" href="/Denot/#8345" class="Bound">Γ</a><a id="8346" class="Symbol">}</a> <a id="8348" class="Symbol">→</a> <a id="8350" class="Symbol">(</a><a id="8351" href="/Denot/#8345" class="Bound">Γ</a> <a id="8353" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="8355" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="8356" class="Symbol">)</a> <a id="8358" class="Symbol">→</a> <a id="8360" href="/Denot/#7488" class="Function">Env</a> <a id="8364" href="/Denot/#8345" class="Bound">Γ</a> <a id="8366" class="Symbol">→</a> <a id="8368" href="/Denot/#4101" class="Datatype">Value</a>
<a id="8374" href="/Denot/#8337" class="Function">nth</a> <a id="8378" href="/Denot/#8378" class="Bound">x</a> <a id="8380" href="/Denot/#8380" class="Bound">ρ</a> <a id="8382" class="Symbol">=</a> <a id="8384" href="/Denot/#8380" class="Bound">ρ</a> <a id="8386" href="/Denot/#8378" class="Bound">x</a></pre>

<p>We extend the <code class="highlighter-rouge">⊑</code> relation point-wise to environments with the
following definition.</p>

<pre class="Agda"><a id="_`⊑_"></a><a id="8499" href="/Denot/#8499" class="Function Operator">_`⊑_</a> <a id="8504" class="Symbol">:</a> <a id="8506" class="Symbol">∀</a> <a id="8508" class="Symbol">{</a><a id="8509" href="/Denot/#8509" class="Bound">Γ</a><a id="8510" class="Symbol">}</a> <a id="8512" class="Symbol">→</a> <a id="8514" href="/Denot/#7488" class="Function">Env</a> <a id="8518" href="/Denot/#8509" class="Bound">Γ</a> <a id="8520" class="Symbol">→</a> <a id="8522" href="/Denot/#7488" class="Function">Env</a> <a id="8526" href="/Denot/#8509" class="Bound">Γ</a> <a id="8528" class="Symbol">→</a> <a id="8530" class="PrimitiveType">Set</a>
<a id="8534" href="/Denot/#8499" class="Function Operator">_`⊑_</a> <a id="8539" class="Symbol">{</a><a id="8540" href="/Denot/#8540" class="Bound">Γ</a><a id="8541" class="Symbol">}</a> <a id="8543" href="/Denot/#8543" class="Bound">γ</a> <a id="8545" href="/Denot/#8545" class="Bound">δ</a> <a id="8547" class="Symbol">=</a> <a id="8549" class="Symbol">∀</a> <a id="8551" class="Symbol">(</a><a id="8552" href="/Denot/#8552" class="Bound">x</a> <a id="8554" class="Symbol">:</a> <a id="8556" href="/Denot/#8540" class="Bound">Γ</a> <a id="8558" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="8560" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="8561" class="Symbol">)</a> <a id="8563" class="Symbol">→</a> <a id="8565" href="/Denot/#8543" class="Bound">γ</a> <a id="8567" href="/Denot/#8552" class="Bound">x</a> <a id="8569" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="8571" href="/Denot/#8545" class="Bound">δ</a> <a id="8573" href="/Denot/#8552" class="Bound">x</a></pre>

<p>We define a bottom environment and a join operator on environments,
which takes the point-wise join of their values.</p>

<pre class="Agda"><a id="`⊥"></a><a id="8718" href="/Denot/#8718" class="Function">`⊥</a> <a id="8721" class="Symbol">:</a> <a id="8723" class="Symbol">∀</a> <a id="8725" class="Symbol">{</a><a id="8726" href="/Denot/#8726" class="Bound">Γ</a><a id="8727" class="Symbol">}</a> <a id="8729" class="Symbol">→</a> <a id="8731" href="/Denot/#7488" class="Function">Env</a> <a id="8735" href="/Denot/#8726" class="Bound">Γ</a>
<a id="8737" href="/Denot/#8718" class="Function">`⊥</a> <a id="8740" href="/Denot/#8740" class="Bound">x</a> <a id="8742" class="Symbol">=</a> <a id="8744" href="/Denot/#4121" class="InductiveConstructor">⊥</a>

<a id="_`⊔_"></a><a id="8747" href="/Denot/#8747" class="Function Operator">_`⊔_</a> <a id="8752" class="Symbol">:</a> <a id="8754" class="Symbol">∀</a> <a id="8756" class="Symbol">{</a><a id="8757" href="/Denot/#8757" class="Bound">Γ</a><a id="8758" class="Symbol">}</a> <a id="8760" class="Symbol">→</a> <a id="8762" href="/Denot/#7488" class="Function">Env</a> <a id="8766" href="/Denot/#8757" class="Bound">Γ</a> <a id="8768" class="Symbol">→</a> <a id="8770" href="/Denot/#7488" class="Function">Env</a> <a id="8774" href="/Denot/#8757" class="Bound">Γ</a> <a id="8776" class="Symbol">→</a> <a id="8778" href="/Denot/#7488" class="Function">Env</a> <a id="8782" href="/Denot/#8757" class="Bound">Γ</a>
<a id="8784" class="Symbol">(</a><a id="8785" href="/Denot/#8785" class="Bound">γ</a> <a id="8787" href="/Denot/#8747" class="Function Operator">`⊔</a> <a id="8790" href="/Denot/#8790" class="Bound">δ</a><a id="8791" class="Symbol">)</a> <a id="8793" href="/Denot/#8793" class="Bound">x</a> <a id="8795" class="Symbol">=</a> <a id="8797" href="/Denot/#8785" class="Bound">γ</a> <a id="8799" href="/Denot/#8793" class="Bound">x</a> <a id="8801" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="8803" href="/Denot/#8790" class="Bound">δ</a> <a id="8805" href="/Denot/#8793" class="Bound">x</a></pre>

<p>The Refl⊑, ConjR1⊑, and ConjR2⊑ rules lift to environments.  So the join of
two environments γ and δ is greater than the first environment γ
or the second environment δ.</p>

<pre class="Agda"><a id="`Refl⊑"></a><a id="9003" href="/Denot/#9003" class="Function">`Refl⊑</a> <a id="9010" class="Symbol">:</a> <a id="9012" class="Symbol">∀</a> <a id="9014" class="Symbol">{</a><a id="9015" href="/Denot/#9015" class="Bound">Γ</a><a id="9016" class="Symbol">}</a> <a id="9018" class="Symbol">{</a><a id="9019" href="/Denot/#9019" class="Bound">γ</a> <a id="9021" class="Symbol">:</a> <a id="9023" href="/Denot/#7488" class="Function">Env</a> <a id="9027" href="/Denot/#9015" class="Bound">Γ</a><a id="9028" class="Symbol">}</a> <a id="9030" class="Symbol">→</a> <a id="9032" href="/Denot/#9019" class="Bound">γ</a> <a id="9034" href="/Denot/#8499" class="Function Operator">`⊑</a> <a id="9037" href="/Denot/#9019" class="Bound">γ</a>
<a id="9039" href="/Denot/#9003" class="Function">`Refl⊑</a> <a id="9046" class="Symbol">{</a><a id="9047" href="/Denot/#9047" class="Bound">Γ</a><a id="9048" class="Symbol">}</a> <a id="9050" class="Symbol">{</a><a id="9051" href="/Denot/#9051" class="Bound">γ</a><a id="9052" class="Symbol">}</a> <a id="9054" href="/Denot/#9054" class="Bound">x</a> <a id="9056" class="Symbol">=</a> <a id="9058" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="9064" class="Symbol">{</a><a id="9065" href="/Denot/#9051" class="Bound">γ</a> <a id="9067" href="/Denot/#9054" class="Bound">x</a><a id="9068" class="Symbol">}</a>

<a id="EnvConjR1⊑"></a><a id="9071" href="/Denot/#9071" class="Function">EnvConjR1⊑</a> <a id="9082" class="Symbol">:</a> <a id="9084" class="Symbol">∀</a> <a id="9086" class="Symbol">{</a><a id="9087" href="/Denot/#9087" class="Bound">Γ</a><a id="9088" class="Symbol">}</a> <a id="9090" class="Symbol">→</a> <a id="9092" class="Symbol">(</a><a id="9093" href="/Denot/#9093" class="Bound">γ</a> <a id="9095" class="Symbol">:</a> <a id="9097" href="/Denot/#7488" class="Function">Env</a> <a id="9101" href="/Denot/#9087" class="Bound">Γ</a><a id="9102" class="Symbol">)</a> <a id="9104" class="Symbol">→</a> <a id="9106" class="Symbol">(</a><a id="9107" href="/Denot/#9107" class="Bound">δ</a> <a id="9109" class="Symbol">:</a> <a id="9111" href="/Denot/#7488" class="Function">Env</a> <a id="9115" href="/Denot/#9087" class="Bound">Γ</a><a id="9116" class="Symbol">)</a> <a id="9118" class="Symbol">→</a> <a id="9120" href="/Denot/#9093" class="Bound">γ</a> <a id="9122" href="/Denot/#8499" class="Function Operator">`⊑</a> <a id="9125" class="Symbol">(</a><a id="9126" href="/Denot/#9093" class="Bound">γ</a> <a id="9128" href="/Denot/#8747" class="Function Operator">`⊔</a> <a id="9131" href="/Denot/#9107" class="Bound">δ</a><a id="9132" class="Symbol">)</a>
<a id="9134" href="/Denot/#9071" class="Function">EnvConjR1⊑</a> <a id="9145" href="/Denot/#9145" class="Bound">γ</a> <a id="9147" href="/Denot/#9147" class="Bound">δ</a> <a id="9149" href="/Denot/#9149" class="Bound">x</a> <a id="9151" class="Symbol">=</a> <a id="9153" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="9161" href="/Denot/#5698" class="Function">Refl⊑</a>

<a id="EnvConjR2⊑"></a><a id="9168" href="/Denot/#9168" class="Function">EnvConjR2⊑</a> <a id="9179" class="Symbol">:</a> <a id="9181" class="Symbol">∀</a> <a id="9183" class="Symbol">{</a><a id="9184" href="/Denot/#9184" class="Bound">Γ</a><a id="9185" class="Symbol">}</a> <a id="9187" class="Symbol">→</a> <a id="9189" class="Symbol">(</a><a id="9190" href="/Denot/#9190" class="Bound">γ</a> <a id="9192" class="Symbol">:</a> <a id="9194" href="/Denot/#7488" class="Function">Env</a> <a id="9198" href="/Denot/#9184" class="Bound">Γ</a><a id="9199" class="Symbol">)</a> <a id="9201" class="Symbol">→</a> <a id="9203" class="Symbol">(</a><a id="9204" href="/Denot/#9204" class="Bound">δ</a> <a id="9206" class="Symbol">:</a> <a id="9208" href="/Denot/#7488" class="Function">Env</a> <a id="9212" href="/Denot/#9184" class="Bound">Γ</a><a id="9213" class="Symbol">)</a> <a id="9215" class="Symbol">→</a> <a id="9217" href="/Denot/#9204" class="Bound">δ</a> <a id="9219" href="/Denot/#8499" class="Function Operator">`⊑</a> <a id="9222" class="Symbol">(</a><a id="9223" href="/Denot/#9190" class="Bound">γ</a> <a id="9225" href="/Denot/#8747" class="Function Operator">`⊔</a> <a id="9228" href="/Denot/#9204" class="Bound">δ</a><a id="9229" class="Symbol">)</a>
<a id="9231" href="/Denot/#9168" class="Function">EnvConjR2⊑</a> <a id="9242" href="/Denot/#9242" class="Bound">γ</a> <a id="9244" href="/Denot/#9244" class="Bound">δ</a> <a id="9246" href="/Denot/#9246" class="Bound">x</a> <a id="9248" class="Symbol">=</a> <a id="9250" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="9258" href="/Denot/#5698" class="Function">Refl⊑</a></pre>

<h2 id="denotational-semantics">Denotational Semantics</h2>

<p>We define the semantics with a judgment of the form <code class="highlighter-rouge">ρ ⊢ M ↓ v</code>,
where <code class="highlighter-rouge">ρ</code> is the environment, <code class="highlighter-rouge">M</code> the program, and <code class="highlighter-rouge">v</code> is a result value.
For readers familiar with big-step semantics, this notation will feel
quite natural, but don’t let the similarity fool you.  There are
subtle but important differences! So here is the definition of the
semantics, which we discuss in detail in the following paragraphs.</p>

<p>[PLW: PLFA doesn’t mention big-step semantics. But perhaps it should!]
[JGS: It does now in the chapter on Adequacy! Though perhaps
  the big-step semantics should be introduced in an earlier
  and proved equivalent to the reduction semantics.]</p>

<pre class="Agda"><a id="9971" class="Keyword">infix</a> <a id="9977" class="Number">3</a> <a id="9979" href="/Denot/#9991" class="Datatype Operator">_⊢_↓_</a>

<a id="9986" class="Keyword">data</a> <a id="_⊢_↓_"></a><a id="9991" href="/Denot/#9991" class="Datatype Operator">_⊢_↓_</a> <a id="9997" class="Symbol">:</a> <a id="9999" class="Symbol">∀{</a><a id="10001" href="/Denot/#10001" class="Bound">Γ</a><a id="10002" class="Symbol">}</a> <a id="10004" class="Symbol">→</a> <a id="10006" href="/Denot/#7488" class="Function">Env</a> <a id="10010" href="/Denot/#10001" class="Bound">Γ</a> <a id="10012" class="Symbol">→</a> <a id="10014" class="Symbol">(</a><a id="10015" href="/Denot/#10001" class="Bound">Γ</a> <a id="10017" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="10019" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="10020" class="Symbol">)</a> <a id="10022" class="Symbol">→</a> <a id="10024" href="/Denot/#4101" class="Datatype">Value</a> <a id="10030" class="Symbol">→</a> <a id="10032" class="PrimitiveType">Set</a> <a id="10036" class="Keyword">where</a>

  <a id="_⊢_↓_.var"></a><a id="10045" href="/Denot/#10045" class="InductiveConstructor">var</a> <a id="10049" class="Symbol">:</a> <a id="10051" class="Symbol">∀</a> <a id="10053" class="Symbol">{</a><a id="10054" href="/Denot/#10054" class="Bound">Γ</a><a id="10055" class="Symbol">}</a> <a id="10057" class="Symbol">{</a><a id="10058" href="/Denot/#10058" class="Bound">γ</a> <a id="10060" class="Symbol">:</a> <a id="10062" href="/Denot/#7488" class="Function">Env</a> <a id="10066" href="/Denot/#10054" class="Bound">Γ</a><a id="10067" class="Symbol">}</a> <a id="10069" class="Symbol">{</a><a id="10070" href="/Denot/#10070" class="Bound">x</a><a id="10071" class="Symbol">}</a>
        <a id="10081" class="Comment">-------------------</a>
      <a id="10107" class="Symbol">→</a> <a id="10109" href="/Denot/#10058" class="Bound">γ</a> <a id="10111" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10113" class="Symbol">(</a><a id="10114" href="/Untyped/#4186" class="InductiveConstructor Operator">`</a> <a id="10116" href="/Denot/#10070" class="Bound">x</a><a id="10117" class="Symbol">)</a> <a id="10119" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10121" href="/Denot/#10058" class="Bound">γ</a> <a id="10123" href="/Denot/#10070" class="Bound">x</a>

  <a id="_⊢_↓_.↦-elim"></a><a id="10128" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="10135" class="Symbol">:</a> <a id="10137" class="Symbol">∀</a> <a id="10139" class="Symbol">{</a><a id="10140" href="/Denot/#10140" class="Bound">Γ</a><a id="10141" class="Symbol">}</a> <a id="10143" class="Symbol">{</a><a id="10144" href="/Denot/#10144" class="Bound">γ</a> <a id="10146" class="Symbol">:</a> <a id="10148" href="/Denot/#7488" class="Function">Env</a> <a id="10152" href="/Denot/#10140" class="Bound">Γ</a><a id="10153" class="Symbol">}</a> <a id="10155" class="Symbol">{</a><a id="10156" href="/Denot/#10156" class="Bound">M₁</a> <a id="10159" href="/Denot/#10159" class="Bound">M₂</a> <a id="10162" href="/Denot/#10162" class="Bound">v₁</a> <a id="10165" href="/Denot/#10165" class="Bound">v₂</a><a id="10167" class="Symbol">}</a>
        <a id="10177" class="Symbol">→</a> <a id="10179" href="/Denot/#10144" class="Bound">γ</a> <a id="10181" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10183" href="/Denot/#10156" class="Bound">M₁</a> <a id="10186" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10188" class="Symbol">(</a><a id="10189" href="/Denot/#10162" class="Bound">v₁</a> <a id="10192" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="10194" href="/Denot/#10165" class="Bound">v₂</a><a id="10196" class="Symbol">)</a>
        <a id="10206" class="Symbol">→</a> <a id="10208" href="/Denot/#10144" class="Bound">γ</a> <a id="10210" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10212" href="/Denot/#10159" class="Bound">M₂</a> <a id="10215" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10217" href="/Denot/#10162" class="Bound">v₁</a>
          <a id="10230" class="Comment">------------------</a>
        <a id="10257" class="Symbol">→</a> <a id="10259" href="/Denot/#10144" class="Bound">γ</a> <a id="10261" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10263" class="Symbol">(</a><a id="10264" href="/Denot/#10156" class="Bound">M₁</a> <a id="10267" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="10269" href="/Denot/#10159" class="Bound">M₂</a><a id="10271" class="Symbol">)</a> <a id="10273" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10275" href="/Denot/#10165" class="Bound">v₂</a>

  <a id="_⊢_↓_.↦-intro"></a><a id="10281" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="10289" class="Symbol">:</a> <a id="10291" class="Symbol">∀</a> <a id="10293" class="Symbol">{</a><a id="10294" href="/Denot/#10294" class="Bound">Γ</a><a id="10295" class="Symbol">}</a> <a id="10297" class="Symbol">{</a><a id="10298" href="/Denot/#10298" class="Bound">γ</a> <a id="10300" class="Symbol">:</a> <a id="10302" href="/Denot/#7488" class="Function">Env</a> <a id="10306" href="/Denot/#10294" class="Bound">Γ</a><a id="10307" class="Symbol">}</a> <a id="10309" class="Symbol">{</a><a id="10310" href="/Denot/#10310" class="Bound">M</a> <a id="10312" href="/Denot/#10312" class="Bound">v₁</a> <a id="10315" href="/Denot/#10315" class="Bound">v₂</a><a id="10317" class="Symbol">}</a>
        <a id="10327" class="Symbol">→</a> <a id="10329" href="/Denot/#10298" class="Bound">γ</a> <a id="10331" href="/Denot/#7646" class="Function Operator">`,</a> <a id="10334" href="/Denot/#10312" class="Bound">v₁</a> <a id="10337" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10339" href="/Denot/#10310" class="Bound">M</a> <a id="10341" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10343" href="/Denot/#10315" class="Bound">v₂</a>
          <a id="10356" class="Comment">---------------------</a>
        <a id="10386" class="Symbol">→</a> <a id="10388" href="/Denot/#10298" class="Bound">γ</a> <a id="10390" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10392" class="Symbol">(</a><a id="10393" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="10395" href="/Denot/#10310" class="Bound">M</a><a id="10396" class="Symbol">)</a> <a id="10398" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10400" class="Symbol">(</a><a id="10401" href="/Denot/#10312" class="Bound">v₁</a> <a id="10404" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="10406" href="/Denot/#10315" class="Bound">v₂</a><a id="10408" class="Symbol">)</a>

  <a id="_⊢_↓_.⊥-intro"></a><a id="10413" href="/Denot/#10413" class="InductiveConstructor">⊥-intro</a> <a id="10421" class="Symbol">:</a> <a id="10423" class="Symbol">∀</a> <a id="10425" class="Symbol">{</a><a id="10426" href="/Denot/#10426" class="Bound">Γ</a><a id="10427" class="Symbol">}</a> <a id="10429" class="Symbol">{</a><a id="10430" href="/Denot/#10430" class="Bound">γ</a> <a id="10432" class="Symbol">:</a> <a id="10434" href="/Denot/#7488" class="Function">Env</a> <a id="10438" href="/Denot/#10426" class="Bound">Γ</a><a id="10439" class="Symbol">}</a> <a id="10441" class="Symbol">{</a><a id="10442" href="/Denot/#10442" class="Bound">M</a><a id="10443" class="Symbol">}</a>
          <a id="10455" class="Comment">---------</a>
        <a id="10473" class="Symbol">→</a> <a id="10475" href="/Denot/#10430" class="Bound">γ</a> <a id="10477" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10479" href="/Denot/#10442" class="Bound">M</a> <a id="10481" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10483" href="/Denot/#4121" class="InductiveConstructor">⊥</a>

  <a id="_⊢_↓_.⊔-intro"></a><a id="10488" href="/Denot/#10488" class="InductiveConstructor">⊔-intro</a> <a id="10496" class="Symbol">:</a> <a id="10498" class="Symbol">∀</a> <a id="10500" class="Symbol">{</a><a id="10501" href="/Denot/#10501" class="Bound">Γ</a><a id="10502" class="Symbol">}</a> <a id="10504" class="Symbol">{</a><a id="10505" href="/Denot/#10505" class="Bound">γ</a> <a id="10507" class="Symbol">:</a> <a id="10509" href="/Denot/#7488" class="Function">Env</a> <a id="10513" href="/Denot/#10501" class="Bound">Γ</a><a id="10514" class="Symbol">}</a> <a id="10516" class="Symbol">{</a><a id="10517" href="/Denot/#10517" class="Bound">M</a> <a id="10519" href="/Denot/#10519" class="Bound">v₁</a> <a id="10522" href="/Denot/#10522" class="Bound">v₂</a><a id="10524" class="Symbol">}</a>
        <a id="10534" class="Symbol">→</a> <a id="10536" href="/Denot/#10505" class="Bound">γ</a> <a id="10538" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10540" href="/Denot/#10517" class="Bound">M</a> <a id="10542" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10544" href="/Denot/#10519" class="Bound">v₁</a>
        <a id="10555" class="Symbol">→</a> <a id="10557" href="/Denot/#10505" class="Bound">γ</a> <a id="10559" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10561" href="/Denot/#10517" class="Bound">M</a> <a id="10563" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10565" href="/Denot/#10522" class="Bound">v₂</a>
          <a id="10578" class="Comment">-----------------</a>
        <a id="10604" class="Symbol">→</a> <a id="10606" href="/Denot/#10505" class="Bound">γ</a> <a id="10608" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10610" href="/Denot/#10517" class="Bound">M</a> <a id="10612" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10614" class="Symbol">(</a><a id="10615" href="/Denot/#10519" class="Bound">v₁</a> <a id="10618" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="10620" href="/Denot/#10522" class="Bound">v₂</a><a id="10622" class="Symbol">)</a>
     
  <a id="_⊢_↓_.sub"></a><a id="10632" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="10636" class="Symbol">:</a> <a id="10638" class="Symbol">∀</a> <a id="10640" class="Symbol">{</a><a id="10641" href="/Denot/#10641" class="Bound">Γ</a><a id="10642" class="Symbol">}</a> <a id="10644" class="Symbol">{</a><a id="10645" href="/Denot/#10645" class="Bound">γ</a> <a id="10647" class="Symbol">:</a> <a id="10649" href="/Denot/#7488" class="Function">Env</a> <a id="10653" href="/Denot/#10641" class="Bound">Γ</a><a id="10654" class="Symbol">}</a> <a id="10656" class="Symbol">{</a><a id="10657" href="/Denot/#10657" class="Bound">M</a> <a id="10659" href="/Denot/#10659" class="Bound">v₁</a> <a id="10662" href="/Denot/#10662" class="Bound">v₂</a><a id="10664" class="Symbol">}</a>
        <a id="10674" class="Symbol">→</a> <a id="10676" href="/Denot/#10645" class="Bound">γ</a> <a id="10678" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10680" href="/Denot/#10657" class="Bound">M</a> <a id="10682" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10684" href="/Denot/#10659" class="Bound">v₁</a>
        <a id="10695" class="Symbol">→</a> <a id="10697" href="/Denot/#10662" class="Bound">v₂</a> <a id="10700" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="10702" href="/Denot/#10659" class="Bound">v₁</a>
          <a id="10715" class="Comment">----------</a>
        <a id="10734" class="Symbol">→</a> <a id="10736" href="/Denot/#10645" class="Bound">γ</a> <a id="10738" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="10740" href="/Denot/#10657" class="Bound">M</a> <a id="10742" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="10744" href="/Denot/#10662" class="Bound">v₂</a></pre>

<p>[PLW: Say we redefine:
  var : ∀ {Γ} {γ : Env Γ} {x}
      → v ⊑ γ x
        ————-
      → γ ⊢ (` x) ↓ v
Then does sub (downward closure) follow from the other rules?]
[JGS: Good question. I’ll look into it. In the past I’ve
 used the above var rule in addition to using ⊑ in ↦-elim.
 But perhaps it is now possible to only use it in var.]</p>

<p>Consider the rule for lambda abstractions, <code class="highlighter-rouge">↦-intro</code>.  It says that a
lambda abstraction results in a single-entry table that maps the input
<code class="highlighter-rouge">v₁</code> to the output <code class="highlighter-rouge">v₂</code>, provided that evaluating the body in an
environment with <code class="highlighter-rouge">v₁</code> bound to its parameter produces the output <code class="highlighter-rouge">v₂</code>.
As a simple example of this rule, we can see that the identity function
maps <code class="highlighter-rouge">⊥</code> to <code class="highlighter-rouge">⊥</code>.</p>

<pre class="Agda"><a id="id"></a><a id="11489" href="/Denot/#11489" class="Function">id</a> <a id="11492" class="Symbol">:</a> <a id="11494" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="11496" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="11498" href="/Untyped/#2694" class="InductiveConstructor">★</a>
<a id="11500" href="/Denot/#11489" class="Function">id</a> <a id="11503" class="Symbol">=</a> <a id="11505" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="11507" href="/Untyped/#4999" class="Function Operator">#</a> <a id="11509" class="Number">0</a></pre>

<pre class="Agda"><a id="denot-id"></a><a id="11536" href="/Denot/#11536" class="Function">denot-id</a> <a id="11545" class="Symbol">:</a> <a id="11547" class="Symbol">∀</a> <a id="11549" class="Symbol">{</a><a id="11550" href="/Denot/#11550" class="Bound">γ</a> <a id="11552" href="/Denot/#11552" class="Bound">v</a><a id="11553" class="Symbol">}</a> <a id="11555" class="Symbol">→</a> <a id="11557" href="/Denot/#11550" class="Bound">γ</a> <a id="11559" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="11561" href="/Denot/#11489" class="Function">id</a> <a id="11564" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="11566" href="/Denot/#11552" class="Bound">v</a> <a id="11568" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="11570" href="/Denot/#11552" class="Bound">v</a>
<a id="11572" href="/Denot/#11536" class="Function">denot-id</a> <a id="11581" class="Symbol">=</a> <a id="11583" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="11591" href="/Denot/#10045" class="InductiveConstructor">var</a>

<a id="denot-id-two"></a><a id="11596" href="/Denot/#11596" class="Function">denot-id-two</a> <a id="11609" class="Symbol">:</a> <a id="11611" class="Symbol">∀</a> <a id="11613" class="Symbol">{</a><a id="11614" href="/Denot/#11614" class="Bound">γ</a> <a id="11616" href="/Denot/#11616" class="Bound">v</a> <a id="11618" href="/Denot/#11618" class="Bound">w</a><a id="11619" class="Symbol">}</a> <a id="11621" class="Symbol">→</a> <a id="11623" href="/Denot/#11614" class="Bound">γ</a> <a id="11625" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="11627" href="/Denot/#11489" class="Function">id</a> <a id="11630" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="11632" class="Symbol">(</a><a id="11633" href="/Denot/#11616" class="Bound">v</a> <a id="11635" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="11637" href="/Denot/#11616" class="Bound">v</a><a id="11638" class="Symbol">)</a> <a id="11640" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="11642" class="Symbol">(</a><a id="11643" href="/Denot/#11618" class="Bound">w</a> <a id="11645" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="11647" href="/Denot/#11618" class="Bound">w</a><a id="11648" class="Symbol">)</a>
<a id="11650" href="/Denot/#11596" class="Function">denot-id-two</a> <a id="11663" class="Symbol">=</a> <a id="11665" href="/Denot/#10488" class="InductiveConstructor">⊔-intro</a> <a id="11673" href="/Denot/#11536" class="Function">denot-id</a> <a id="11682" href="/Denot/#11536" class="Function">denot-id</a></pre>

<p>Of course, we will need tables with many rows for our lambda
abstractions. These can be constructed using the (⊔-intro) rule.  If
term M (typically a lambda abstraction) can produce both tables v₁ and
v₂, then it produces the combined table v₁ ⊔ v₂. One can take an
operational view of the rules (↦-intro) and (⊔-intro) by 
imagining that when an interpreter first comes to a lambda
abstraction, it pre-evaluates the function on a bunch of randomly
chosen arguments, using many instances of the rule (↦-intro), and then
joins them into one table using many instances of the rule (⊔-intro).
In the following we show that the identity function produces a table
containing both of the previous results, ⊥ ↦ ⊥ and (⊥ ↦ ⊥) ↦ (⊥ ↦ ⊥).</p>

<pre class="Agda"><a id="denot-id3"></a><a id="12446" href="/Denot/#12446" class="Function">denot-id3</a> <a id="12456" class="Symbol">:</a> <a id="12458" href="/Denot/#7628" class="Function">`∅</a> <a id="12461" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="12463" href="/Denot/#11489" class="Function">id</a> <a id="12466" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="12468" class="Symbol">(</a><a id="12469" href="/Denot/#4121" class="InductiveConstructor">⊥</a> <a id="12471" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="12473" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="12474" class="Symbol">)</a> <a id="12476" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="12478" class="Symbol">(</a><a id="12479" href="/Denot/#4121" class="InductiveConstructor">⊥</a> <a id="12481" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="12483" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="12484" class="Symbol">)</a> <a id="12486" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="12488" class="Symbol">(</a><a id="12489" href="/Denot/#4121" class="InductiveConstructor">⊥</a> <a id="12491" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="12493" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="12494" class="Symbol">)</a>
<a id="12496" href="/Denot/#12446" class="Function">denot-id3</a> <a id="12506" class="Symbol">=</a> <a id="12508" href="/Denot/#11596" class="Function">denot-id-two</a></pre>

<p>We most often think of the judgment γ ⊢ M ↓ v as taking the
environment γ and term M as input, producing the result v.  However,
it is worth emphasizing that the semantics is a <em>relation</em>.  The above
results for the identity function show that the same environment and
term can be mapped to different results. However, the results for a
given γ and M are not <em>too</em> different, they are all finite
approximations of the same function. Perhaps a better way of thinking
about the judgment γ ⊢ M ↓ v is that the γ, M, and v are all inputs
and the semantics either confirms or denies whether v is an accurate
partial description of the result of M in environment γ.</p>

<p>Next we consider the meaning of function application as given by the
(↦-elim) rule. In the premise of the rule we have that M₁ maps v₁ to
v₂. So if M₂ produces v₁, then the application of M₁ to M₂ produces
v₂.</p>

<p>As an example of function application and the (↦-elim) rule, we apply
the identity function to itself.  Indeed, we have both that ∅ ⊢ id
↓ (v’ ↦ v’) ↦ (v’ ↦ v’) and also ∅ ⊢ id ↓ (v’ ↦ v’), so we can
apply the rule (↦-elim).</p>

<pre class="Agda"><a id="id-app-id"></a><a id="13644" href="/Denot/#13644" class="Function">id-app-id</a> <a id="13654" class="Symbol">:</a> <a id="13656" class="Symbol">∀</a> <a id="13658" class="Symbol">{</a><a id="13659" href="/Denot/#13659" class="Bound">v&#39;</a> <a id="13662" class="Symbol">:</a> <a id="13664" href="/Denot/#4101" class="Datatype">Value</a><a id="13669" class="Symbol">}</a> <a id="13671" class="Symbol">→</a> <a id="13673" href="/Denot/#7628" class="Function">`∅</a> <a id="13676" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="13678" href="/Denot/#11489" class="Function">id</a> <a id="13681" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="13683" href="/Denot/#11489" class="Function">id</a> <a id="13686" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="13688" class="Symbol">(</a><a id="13689" href="/Denot/#13659" class="Bound">v&#39;</a> <a id="13692" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="13694" href="/Denot/#13659" class="Bound">v&#39;</a><a id="13696" class="Symbol">)</a>
<a id="13698" href="/Denot/#13644" class="Function">id-app-id</a> <a id="13708" class="Symbol">{</a><a id="13709" href="/Denot/#13709" class="Bound">v&#39;</a><a id="13711" class="Symbol">}</a> <a id="13713" class="Symbol">=</a> <a id="13715" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="13722" class="Symbol">(</a><a id="13723" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="13731" href="/Denot/#10045" class="InductiveConstructor">var</a><a id="13734" class="Symbol">)</a> <a id="13736" class="Symbol">(</a><a id="13737" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="13745" href="/Denot/#10045" class="InductiveConstructor">var</a><a id="13748" class="Symbol">)</a></pre>

<p>Next we revisit the Church numeral two.  This function has two
parameters: a function and an arbitrary value v₁, and it applies the
function twice. So the function must map v₁ to some value, which we’ll
name v₂. Then for the second application, it must map v₂ to some
value. Let’s name it v₃. So the parameter’s table must contain two
entries, both v₁ ↦ v₂ and v₂ ↦ v₃. For each application of the table,
we extract the appropriate entry from it using the (sub) rule.  In
particular, we use the ConjR1⊑ and ConjR2⊑ to select v₁ ↦ v₂ and v₂ ↦
v₃, respectively, from the table v₁ ↦ v₂ ⊔ v₂ ↦ v₃. So the meaning of
twoᶜ is that it takes this table and parameter v₁, and it returns v₃.
Indeed we derive this as follows.</p>

<pre class="Agda"><a id="denot-twoᶜ"></a><a id="14492" href="/Denot/#14492" class="Function">denot-twoᶜ</a> <a id="14503" class="Symbol">:</a> <a id="14505" class="Symbol">∀{</a><a id="14507" href="/Denot/#14507" class="Bound">v₁</a> <a id="14510" href="/Denot/#14510" class="Bound">v₂</a> <a id="14513" href="/Denot/#14513" class="Bound">v₃</a> <a id="14516" class="Symbol">:</a> <a id="14518" href="/Denot/#4101" class="Datatype">Value</a><a id="14523" class="Symbol">}</a> <a id="14525" class="Symbol">→</a> <a id="14527" href="/Denot/#7628" class="Function">`∅</a> <a id="14530" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="14532" href="/Untyped/#5146" class="Function">twoᶜ</a> <a id="14537" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="14539" class="Symbol">((</a><a id="14541" href="/Denot/#14507" class="Bound">v₁</a> <a id="14544" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14546" href="/Denot/#14510" class="Bound">v₂</a> <a id="14549" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="14551" href="/Denot/#14510" class="Bound">v₂</a> <a id="14554" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14556" href="/Denot/#14513" class="Bound">v₃</a><a id="14558" class="Symbol">)</a> <a id="14560" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14562" class="Symbol">(</a><a id="14563" href="/Denot/#14507" class="Bound">v₁</a> <a id="14566" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14568" href="/Denot/#14513" class="Bound">v₃</a><a id="14570" class="Symbol">))</a>
<a id="14573" href="/Denot/#14492" class="Function">denot-twoᶜ</a> <a id="14584" class="Symbol">{</a><a id="14585" href="/Denot/#14585" class="Bound">v₁</a><a id="14587" class="Symbol">}{</a><a id="14589" href="/Denot/#14589" class="Bound">v₂</a><a id="14591" class="Symbol">}{</a><a id="14593" href="/Denot/#14593" class="Bound">v₃</a><a id="14595" class="Symbol">}</a> <a id="14597" class="Symbol">=</a>
  <a id="14601" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="14609" class="Symbol">(</a><a id="14610" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="14618" class="Symbol">(</a><a id="14619" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="14626" class="Symbol">(</a><a id="14627" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="14631" href="/Denot/#10045" class="InductiveConstructor">var</a> <a id="14635" href="/Denot/#14677" class="Function">lt1</a><a id="14638" class="Symbol">)</a> <a id="14640" class="Symbol">(</a><a id="14641" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="14648" class="Symbol">(</a><a id="14649" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="14653" href="/Denot/#10045" class="InductiveConstructor">var</a> <a id="14657" href="/Denot/#14766" class="Function">lt2</a><a id="14660" class="Symbol">)</a> <a id="14662" href="/Denot/#10045" class="InductiveConstructor">var</a><a id="14665" class="Symbol">)))</a>
  <a id="14671" class="Keyword">where</a> <a id="14677" href="/Denot/#14677" class="Function">lt1</a> <a id="14681" class="Symbol">:</a> <a id="14683" href="/Denot/#14589" class="Bound">v₂</a> <a id="14686" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14688" href="/Denot/#14593" class="Bound">v₃</a> <a id="14691" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="14693" href="/Denot/#14585" class="Bound">v₁</a> <a id="14696" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14698" href="/Denot/#14589" class="Bound">v₂</a> <a id="14701" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="14703" href="/Denot/#14589" class="Bound">v₂</a> <a id="14706" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14708" href="/Denot/#14593" class="Bound">v₃</a>
        <a id="14719" href="/Denot/#14677" class="Function">lt1</a> <a id="14723" class="Symbol">=</a> <a id="14725" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="14733" class="Symbol">(</a><a id="14734" href="/Denot/#4875" class="InductiveConstructor">Fun⊑</a> <a id="14739" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="14745" href="/Denot/#5698" class="Function">Refl⊑</a><a id="14750" class="Symbol">)</a>
     
        <a id="14766" href="/Denot/#14766" class="Function">lt2</a> <a id="14770" class="Symbol">:</a> <a id="14772" href="/Denot/#14585" class="Bound">v₁</a> <a id="14775" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14777" href="/Denot/#14589" class="Bound">v₂</a> <a id="14780" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="14782" href="/Denot/#14585" class="Bound">v₁</a> <a id="14785" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14787" href="/Denot/#14589" class="Bound">v₂</a> <a id="14790" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="14792" href="/Denot/#14589" class="Bound">v₂</a> <a id="14795" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="14797" href="/Denot/#14593" class="Bound">v₃</a>
        <a id="14808" href="/Denot/#14766" class="Function">lt2</a> <a id="14812" class="Symbol">=</a> <a id="14814" class="Symbol">(</a><a id="14815" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="14823" class="Symbol">(</a><a id="14824" href="/Denot/#4875" class="InductiveConstructor">Fun⊑</a> <a id="14829" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="14835" href="/Denot/#5698" class="Function">Refl⊑</a><a id="14840" class="Symbol">))</a></pre>

<p>Next we have a classic example of self application: Δ = λx. (x x).
The input value for x needs to be a table, and it needs to have an
entry that maps a smaller version of itself, call it v₁, to some value
v₂. So the input value looks like v₁ ↦ v₂ ⊔ v₁. Of course, then the
output of Δ is v₂. The derivation is given below.  The first occurrences
of x evaluates to v₁ ↦ v₂, the second occurrence of x evaluates to v₁,
and then the result of the application is v₂.</p>

<pre class="Agda"><a id="Δ"></a><a id="15333" href="/Denot/#15333" class="Function">Δ</a> <a id="15335" class="Symbol">:</a> <a id="15337" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="15339" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="15341" href="/Untyped/#2694" class="InductiveConstructor">★</a>
<a id="15343" href="/Denot/#15333" class="Function">Δ</a> <a id="15345" class="Symbol">=</a> <a id="15347" class="Symbol">(</a><a id="15348" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="15350" class="Symbol">(</a><a id="15351" href="/Untyped/#4999" class="Function Operator">#</a> <a id="15353" class="Number">0</a><a id="15354" class="Symbol">)</a> <a id="15356" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="15358" class="Symbol">(</a><a id="15359" href="/Untyped/#4999" class="Function Operator">#</a> <a id="15361" class="Number">0</a><a id="15362" class="Symbol">))</a>

<a id="denot-Δ"></a><a id="15366" href="/Denot/#15366" class="Function">denot-Δ</a> <a id="15374" class="Symbol">:</a> <a id="15376" class="Symbol">∀</a> <a id="15378" class="Symbol">{</a><a id="15379" href="/Denot/#15379" class="Bound">v₁</a> <a id="15382" href="/Denot/#15382" class="Bound">v₂</a><a id="15384" class="Symbol">}</a> <a id="15386" class="Symbol">→</a> <a id="15388" href="/Denot/#7628" class="Function">`∅</a> <a id="15391" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="15393" href="/Denot/#15333" class="Function">Δ</a> <a id="15395" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="15397" class="Symbol">((</a><a id="15399" href="/Denot/#15379" class="Bound">v₁</a> <a id="15402" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="15404" href="/Denot/#15382" class="Bound">v₂</a> <a id="15407" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="15409" href="/Denot/#15379" class="Bound">v₁</a><a id="15411" class="Symbol">)</a> <a id="15413" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="15415" href="/Denot/#15382" class="Bound">v₂</a><a id="15417" class="Symbol">)</a>
<a id="15419" href="/Denot/#15366" class="Function">denot-Δ</a> <a id="15427" class="Symbol">{</a><a id="15428" href="/Denot/#15428" class="Bound">v₁</a><a id="15430" class="Symbol">}{</a><a id="15432" href="/Denot/#15432" class="Bound">v₂</a><a id="15434" class="Symbol">}</a> <a id="15436" class="Symbol">=</a> <a id="15438" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="15446" class="Symbol">(</a><a id="15447" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="15454" class="Symbol">(</a><a id="15455" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="15459" href="/Denot/#10045" class="InductiveConstructor">var</a> <a id="15463" class="Symbol">(</a><a id="15464" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="15472" href="/Denot/#5698" class="Function">Refl⊑</a><a id="15477" class="Symbol">))</a>
                                   <a id="15515" class="Symbol">(</a><a id="15516" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="15520" href="/Denot/#10045" class="InductiveConstructor">var</a> <a id="15524" class="Symbol">(</a><a id="15525" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="15533" href="/Denot/#5698" class="Function">Refl⊑</a><a id="15538" class="Symbol">)))</a></pre>

<p>One might worry whether this semantics can deal with diverging
programs.  The ⊥ value and the (⊥-intro) rule provide a way to handle
them. (The (⊥-intro) rule is also what enables β reduction on
non-terminating arguments.)  The classic Ω program is a particularly
simple program that diverges. It applies Δ to itself. The semantics
assigns to Ω the meaning ⊥. There are several ways to derive this, we
shall start with one that makes use of the (⊔-intro) rule.  First,
denot-Δ tells us that Δ evaluates to ((⊥ ↦ ⊥) ⊔ ⊥) ↦ ⊥ (choose v₁ = v₂
= ⊥).  Next, Δ also evaluates to ⊥ ↦ ⊥ by use of (↦-intro) and
(⊥-intro) and to ⊥ by (⊥-intro). As we saw previously, whenever we can
show that a program evaluates to two values, we can apply (⊔-intro) to
join them together, so Δ evaluates to (⊥ ↦ ⊥) ⊔ ⊥. This matches the
input of the first occurrence of Δ, so we can conclude that the result
of the application is ⊥.</p>

<pre class="Agda"><a id="Ω"></a><a id="16477" href="/Denot/#16477" class="Function">Ω</a> <a id="16479" class="Symbol">:</a> <a id="16481" href="/Untyped/#3002" class="InductiveConstructor">∅</a> <a id="16483" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="16485" href="/Untyped/#2694" class="InductiveConstructor">★</a>
<a id="16487" href="/Denot/#16477" class="Function">Ω</a> <a id="16489" class="Symbol">=</a> <a id="16491" href="/Denot/#15333" class="Function">Δ</a> <a id="16493" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="16495" href="/Denot/#15333" class="Function">Δ</a>

<a id="denot-Ω"></a><a id="16498" href="/Denot/#16498" class="Function">denot-Ω</a> <a id="16506" class="Symbol">:</a> <a id="16508" href="/Denot/#7628" class="Function">`∅</a> <a id="16511" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="16513" href="/Denot/#16477" class="Function">Ω</a> <a id="16515" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="16517" href="/Denot/#4121" class="InductiveConstructor">⊥</a>
<a id="16519" href="/Denot/#16498" class="Function">denot-Ω</a> <a id="16527" class="Symbol">=</a> <a id="16529" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="16536" href="/Denot/#15366" class="Function">denot-Δ</a> <a id="16544" class="Symbol">(</a><a id="16545" href="/Denot/#10488" class="InductiveConstructor">⊔-intro</a> <a id="16553" class="Symbol">(</a><a id="16554" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="16562" href="/Denot/#10413" class="InductiveConstructor">⊥-intro</a><a id="16569" class="Symbol">)</a> <a id="16571" href="/Denot/#10413" class="InductiveConstructor">⊥-intro</a><a id="16578" class="Symbol">)</a></pre>

<p>A shorter derivation of the same result is by just one use of the
(⊥-intro) rule.</p>

<pre class="Agda"><a id="denot-Ω&#39;"></a><a id="16689" href="/Denot/#16689" class="Function">denot-Ω&#39;</a> <a id="16698" class="Symbol">:</a> <a id="16700" href="/Denot/#7628" class="Function">`∅</a> <a id="16703" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="16705" href="/Denot/#16477" class="Function">Ω</a> <a id="16707" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="16709" href="/Denot/#4121" class="InductiveConstructor">⊥</a>
<a id="16711" href="/Denot/#16689" class="Function">denot-Ω&#39;</a> <a id="16720" class="Symbol">=</a> <a id="16722" href="/Denot/#10413" class="InductiveConstructor">⊥-intro</a></pre>

<p>Just because one can derive `∅ ⊢ M ↓ ⊥ for some closed term M doesn’t mean
that M necessarily diverges. There may be other derivations that
conclude with M producing some more informative value.  However, if
the only thing that a term evaluates to is ⊥, then it indeed it
diverges.</p>

<p>An attentive reader may have noticed a disconnect earlier in the way
we planned to solve the self-application problem and the actual
(↦-elim) rule for application. We said at the beginning that we would
relax the notion of table lookup, allowing an argument to match an
input entry if the argument is equal or greater than the input entry.
Instead, the (↦-elim) rule seems to require an exact match.  However,
because of the (sub) rule, application really does allow larger
arguments.</p>

<pre class="Agda"><a id="↦-elim2"></a><a id="17524" href="/Denot/#17524" class="Function">↦-elim2</a> <a id="17532" class="Symbol">:</a> <a id="17534" class="Symbol">∀</a> <a id="17536" class="Symbol">{</a><a id="17537" href="/Denot/#17537" class="Bound">Γ</a><a id="17538" class="Symbol">}</a> <a id="17540" class="Symbol">{</a><a id="17541" href="/Denot/#17541" class="Bound">γ</a> <a id="17543" class="Symbol">:</a> <a id="17545" href="/Denot/#7488" class="Function">Env</a> <a id="17549" href="/Denot/#17537" class="Bound">Γ</a><a id="17550" class="Symbol">}</a> <a id="17552" class="Symbol">{</a><a id="17553" href="/Denot/#17553" class="Bound">M₁</a> <a id="17556" href="/Denot/#17556" class="Bound">M₂</a> <a id="17559" href="/Denot/#17559" class="Bound">v₁</a> <a id="17562" href="/Denot/#17562" class="Bound">v₂</a> <a id="17565" href="/Denot/#17565" class="Bound">v₃</a><a id="17567" class="Symbol">}</a>
        <a id="17577" class="Symbol">→</a> <a id="17579" href="/Denot/#17541" class="Bound">γ</a> <a id="17581" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="17583" href="/Denot/#17553" class="Bound">M₁</a> <a id="17586" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="17588" class="Symbol">(</a><a id="17589" href="/Denot/#17559" class="Bound">v₁</a> <a id="17592" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="17594" href="/Denot/#17565" class="Bound">v₃</a><a id="17596" class="Symbol">)</a>
        <a id="17606" class="Symbol">→</a> <a id="17608" href="/Denot/#17541" class="Bound">γ</a> <a id="17610" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="17612" href="/Denot/#17556" class="Bound">M₂</a> <a id="17615" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="17617" href="/Denot/#17562" class="Bound">v₂</a>
        <a id="17628" class="Symbol">→</a> <a id="17630" href="/Denot/#17559" class="Bound">v₁</a> <a id="17633" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="17635" href="/Denot/#17562" class="Bound">v₂</a>
          <a id="17648" class="Comment">------------------</a>
        <a id="17675" class="Symbol">→</a> <a id="17677" href="/Denot/#17541" class="Bound">γ</a> <a id="17679" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="17681" class="Symbol">(</a><a id="17682" href="/Denot/#17553" class="Bound">M₁</a> <a id="17685" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="17687" href="/Denot/#17556" class="Bound">M₂</a><a id="17689" class="Symbol">)</a> <a id="17691" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="17693" href="/Denot/#17565" class="Bound">v₃</a>
<a id="17696" href="/Denot/#17524" class="Function">↦-elim2</a> <a id="17704" href="/Denot/#17704" class="Bound">d₁</a> <a id="17707" href="/Denot/#17707" class="Bound">d₂</a> <a id="17710" href="/Denot/#17710" class="Bound">lt</a> <a id="17713" class="Symbol">=</a> <a id="17715" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="17722" href="/Denot/#17704" class="Bound">d₁</a> <a id="17725" class="Symbol">(</a><a id="17726" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="17730" href="/Denot/#17707" class="Bound">d₂</a> <a id="17733" href="/Denot/#17710" class="Bound">lt</a><a id="17735" class="Symbol">)</a></pre>

<h2 id="denotations-and-denotational-equality">Denotations and denotational equality</h2>

<p>Next we define a notion of denotational equality based on the above
semantics. Its statement makes use of an if-and-only-if, which we
define as follows.</p>

<pre class="Agda"><a id="_iff_"></a><a id="17959" href="/Denot/#17959" class="Function Operator">_iff_</a> <a id="17965" class="Symbol">:</a> <a id="17967" class="PrimitiveType">Set</a> <a id="17971" class="Symbol">→</a> <a id="17973" class="PrimitiveType">Set</a> <a id="17977" class="Symbol">→</a> <a id="17979" class="PrimitiveType">Set</a>
<a id="17983" href="/Denot/#17983" class="Bound">P</a> <a id="17985" href="/Denot/#17959" class="Function Operator">iff</a> <a id="17989" href="/Denot/#17989" class="Bound">Q</a> <a id="17991" class="Symbol">=</a> <a id="17993" class="Symbol">(</a><a id="17994" href="/Denot/#17983" class="Bound">P</a> <a id="17996" class="Symbol">→</a> <a id="17998" href="/Denot/#17989" class="Bound">Q</a><a id="17999" class="Symbol">)</a> <a id="18001" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="18003" class="Symbol">(</a><a id="18004" href="/Denot/#17989" class="Bound">Q</a> <a id="18006" class="Symbol">→</a> <a id="18008" href="/Denot/#17983" class="Bound">P</a><a id="18009" class="Symbol">)</a></pre>

<p>Another way to view the denotational semantics is as a function that
maps a term to a relation from environments to values.  That is, the
<em>denotation</em> of a term is a relation from environments to values.</p>

<pre class="Agda"><a id="Denotation"></a><a id="18241" href="/Denot/#18241" class="Function">Denotation</a> <a id="18252" class="Symbol">:</a> <a id="18254" href="/Untyped/#2980" class="Datatype">Context</a> <a id="18262" class="Symbol">→</a> <a id="18264" class="PrimitiveType">Set₁</a>
<a id="18269" href="/Denot/#18241" class="Function">Denotation</a> <a id="18280" href="/Denot/#18280" class="Bound">Γ</a> <a id="18282" class="Symbol">=</a> <a id="18284" class="Symbol">(</a><a id="18285" href="/Denot/#7488" class="Function">Env</a> <a id="18289" href="/Denot/#18280" class="Bound">Γ</a> <a id="18291" class="Symbol">→</a> <a id="18293" href="/Denot/#4101" class="Datatype">Value</a> <a id="18299" class="Symbol">→</a> <a id="18301" class="PrimitiveType">Set</a><a id="18304" class="Symbol">)</a></pre>

<p>The following function ℰ gives this alternative view of the semantics,
which really just amounts to changing the order of the parameters.</p>

<pre class="Agda"><a id="ℰ"></a><a id="18470" href="/Denot/#18470" class="Function">ℰ</a> <a id="18472" class="Symbol">:</a> <a id="18474" class="Symbol">∀{</a><a id="18476" href="/Denot/#18476" class="Bound">Γ</a><a id="18477" class="Symbol">}</a> <a id="18479" class="Symbol">→</a> <a id="18481" class="Symbol">(</a><a id="18482" href="/Denot/#18482" class="Bound">M</a> <a id="18484" class="Symbol">:</a> <a id="18486" href="/Denot/#18476" class="Bound">Γ</a> <a id="18488" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="18490" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="18491" class="Symbol">)</a> <a id="18493" class="Symbol">→</a> <a id="18495" href="/Denot/#18241" class="Function">Denotation</a> <a id="18506" href="/Denot/#18476" class="Bound">Γ</a>
<a id="18508" href="/Denot/#18470" class="Function">ℰ</a> <a id="18510" href="/Denot/#18510" class="Bound">M</a> <a id="18512" class="Symbol">=</a> <a id="18514" class="Symbol">λ</a> <a id="18516" href="/Denot/#18516" class="Bound">γ</a> <a id="18518" href="/Denot/#18518" class="Bound">v</a> <a id="18520" class="Symbol">→</a> <a id="18522" href="/Denot/#18516" class="Bound">γ</a> <a id="18524" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="18526" href="/Denot/#18510" class="Bound">M</a> <a id="18528" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="18530" href="/Denot/#18518" class="Bound">v</a></pre>

<p>In general, two denotations are equal when they produce the same
values in the same environment.</p>

<pre class="Agda"><a id="18655" class="Keyword">infix</a> <a id="18661" class="Number">3</a> <a id="18663" href="/Denot/#18668" class="Function Operator">_≃_</a>

<a id="_≃_"></a><a id="18668" href="/Denot/#18668" class="Function Operator">_≃_</a> <a id="18672" class="Symbol">:</a> <a id="18674" class="Symbol">∀</a> <a id="18676" class="Symbol">{</a><a id="18677" href="/Denot/#18677" class="Bound">Γ</a><a id="18678" class="Symbol">}</a> <a id="18680" class="Symbol">→</a> <a id="18682" class="Symbol">(</a><a id="18683" href="/Denot/#18241" class="Function">Denotation</a> <a id="18694" href="/Denot/#18677" class="Bound">Γ</a><a id="18695" class="Symbol">)</a> <a id="18697" class="Symbol">→</a> <a id="18699" class="Symbol">(</a><a id="18700" href="/Denot/#18241" class="Function">Denotation</a> <a id="18711" href="/Denot/#18677" class="Bound">Γ</a><a id="18712" class="Symbol">)</a> <a id="18714" class="Symbol">→</a> <a id="18716" class="PrimitiveType">Set</a>
<a id="18720" href="/Denot/#18720" class="Bound">D₁</a> <a id="18723" href="/Denot/#18668" class="Function Operator">≃</a> <a id="18725" href="/Denot/#18725" class="Bound">D₂</a> <a id="18728" class="Symbol">=</a> <a id="18730" class="Symbol">∀</a> <a id="18732" class="Symbol">{</a><a id="18733" href="/Denot/#18733" class="Bound">γ</a><a id="18734" class="Symbol">}</a> <a id="18736" class="Symbol">{</a><a id="18737" href="/Denot/#18737" class="Bound">v</a><a id="18738" class="Symbol">}</a> <a id="18740" class="Symbol">→</a> <a id="18742" href="/Denot/#18720" class="Bound">D₁</a> <a id="18745" href="/Denot/#18733" class="Bound">γ</a> <a id="18747" href="/Denot/#18737" class="Bound">v</a> <a id="18749" href="/Denot/#17959" class="Function Operator">iff</a> <a id="18753" href="/Denot/#18725" class="Bound">D₂</a> <a id="18756" href="/Denot/#18733" class="Bound">γ</a> <a id="18758" href="/Denot/#18737" class="Bound">v</a></pre>

<p>Denotational equality is an equivalence relation.</p>

<pre class="Agda"><a id="≃-refl"></a><a id="18836" href="/Denot/#18836" class="Function">≃-refl</a> <a id="18843" class="Symbol">:</a> <a id="18845" class="Symbol">∀</a> <a id="18847" class="Symbol">{</a><a id="18848" href="/Denot/#18848" class="Bound">Γ</a> <a id="18850" class="Symbol">:</a> <a id="18852" href="/Untyped/#2980" class="Datatype">Context</a><a id="18859" class="Symbol">}</a> <a id="18861" class="Symbol">→</a> <a id="18863" class="Symbol">{</a><a id="18864" href="/Denot/#18864" class="Bound">M</a> <a id="18866" class="Symbol">:</a> <a id="18868" href="/Denot/#18241" class="Function">Denotation</a> <a id="18879" href="/Denot/#18848" class="Bound">Γ</a><a id="18880" class="Symbol">}</a>
  <a id="18884" class="Symbol">→</a> <a id="18886" href="/Denot/#18864" class="Bound">M</a> <a id="18888" href="/Denot/#18668" class="Function Operator">≃</a> <a id="18890" href="/Denot/#18864" class="Bound">M</a>
<a id="18892" href="/Denot/#18836" class="Function">≃-refl</a> <a id="18899" class="Symbol">=</a> <a id="18901" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="18903" class="Symbol">(λ</a> <a id="18906" href="/Denot/#18906" class="Bound">x</a> <a id="18908" class="Symbol">→</a> <a id="18910" href="/Denot/#18906" class="Bound">x</a><a id="18911" class="Symbol">)</a> <a id="18913" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="18915" class="Symbol">(λ</a> <a id="18918" href="/Denot/#18918" class="Bound">x</a> <a id="18920" class="Symbol">→</a> <a id="18922" href="/Denot/#18918" class="Bound">x</a><a id="18923" class="Symbol">)</a> <a id="18925" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>

<a id="≃-sym"></a><a id="18928" href="/Denot/#18928" class="Function">≃-sym</a> <a id="18934" class="Symbol">:</a> <a id="18936" class="Symbol">∀</a> <a id="18938" class="Symbol">{</a><a id="18939" href="/Denot/#18939" class="Bound">Γ</a> <a id="18941" class="Symbol">:</a> <a id="18943" href="/Untyped/#2980" class="Datatype">Context</a><a id="18950" class="Symbol">}</a> <a id="18952" class="Symbol">→</a> <a id="18954" class="Symbol">{</a><a id="18955" href="/Denot/#18955" class="Bound">M</a> <a id="18957" href="/Denot/#18957" class="Bound">N</a> <a id="18959" class="Symbol">:</a> <a id="18961" href="/Denot/#18241" class="Function">Denotation</a> <a id="18972" href="/Denot/#18939" class="Bound">Γ</a><a id="18973" class="Symbol">}</a>
  <a id="18977" class="Symbol">→</a> <a id="18979" href="/Denot/#18955" class="Bound">M</a> <a id="18981" href="/Denot/#18668" class="Function Operator">≃</a> <a id="18983" href="/Denot/#18957" class="Bound">N</a>
    <a id="18989" class="Comment">-----</a>
  <a id="18997" class="Symbol">→</a> <a id="18999" href="/Denot/#18957" class="Bound">N</a> <a id="19001" href="/Denot/#18668" class="Function Operator">≃</a> <a id="19003" href="/Denot/#18955" class="Bound">M</a>
<a id="19005" href="/Denot/#18928" class="Function">≃-sym</a> <a id="19011" href="/Denot/#19011" class="Bound">eq</a> <a id="19014" class="Symbol">=</a> <a id="19016" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="19018" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#167" class="Field">proj₂</a> <a id="19024" href="/Denot/#19011" class="Bound">eq</a> <a id="19027" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="19029" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#155" class="Field">proj₁</a> <a id="19035" href="/Denot/#19011" class="Bound">eq</a> <a id="19038" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>

<a id="≃-trans"></a><a id="19041" href="/Denot/#19041" class="Function">≃-trans</a> <a id="19049" class="Symbol">:</a> <a id="19051" class="Symbol">∀</a> <a id="19053" class="Symbol">{</a><a id="19054" href="/Denot/#19054" class="Bound">Γ</a> <a id="19056" class="Symbol">:</a> <a id="19058" href="/Untyped/#2980" class="Datatype">Context</a><a id="19065" class="Symbol">}</a> <a id="19067" class="Symbol">→</a> <a id="19069" class="Symbol">{</a><a id="19070" href="/Denot/#19070" class="Bound">M₁</a> <a id="19073" href="/Denot/#19073" class="Bound">M₂</a> <a id="19076" href="/Denot/#19076" class="Bound">M₃</a> <a id="19079" class="Symbol">:</a> <a id="19081" href="/Denot/#18241" class="Function">Denotation</a> <a id="19092" href="/Denot/#19054" class="Bound">Γ</a><a id="19093" class="Symbol">}</a>
  <a id="19097" class="Symbol">→</a> <a id="19099" href="/Denot/#19070" class="Bound">M₁</a> <a id="19102" href="/Denot/#18668" class="Function Operator">≃</a> <a id="19104" href="/Denot/#19073" class="Bound">M₂</a>
  <a id="19109" class="Symbol">→</a> <a id="19111" href="/Denot/#19073" class="Bound">M₂</a> <a id="19114" href="/Denot/#18668" class="Function Operator">≃</a> <a id="19116" href="/Denot/#19076" class="Bound">M₃</a>
    <a id="19123" class="Comment">-------</a>
  <a id="19133" class="Symbol">→</a> <a id="19135" href="/Denot/#19070" class="Bound">M₁</a> <a id="19138" href="/Denot/#18668" class="Function Operator">≃</a> <a id="19140" href="/Denot/#19076" class="Bound">M₃</a>
<a id="19143" href="/Denot/#19041" class="Function">≃-trans</a> <a id="19151" href="/Denot/#19151" class="Bound">eq1</a> <a id="19155" href="/Denot/#19155" class="Bound">eq2</a> <a id="19159" class="Symbol">=</a>
  <a id="19163" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="19165" class="Symbol">(λ</a> <a id="19168" href="/Denot/#19168" class="Bound">z</a> <a id="19170" class="Symbol">→</a> <a id="19172" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#155" class="Field">proj₁</a> <a id="19178" href="/Denot/#19155" class="Bound">eq2</a> <a id="19182" class="Symbol">(</a><a id="19183" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#155" class="Field">proj₁</a> <a id="19189" href="/Denot/#19151" class="Bound">eq1</a> <a id="19193" href="/Denot/#19168" class="Bound">z</a><a id="19194" class="Symbol">))</a> <a id="19197" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="19199" class="Symbol">(λ</a> <a id="19202" href="/Denot/#19202" class="Bound">z</a> <a id="19204" class="Symbol">→</a> <a id="19206" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#167" class="Field">proj₂</a> <a id="19212" href="/Denot/#19151" class="Bound">eq1</a> <a id="19216" class="Symbol">(</a><a id="19217" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#167" class="Field">proj₂</a> <a id="19223" href="/Denot/#19155" class="Bound">eq2</a> <a id="19227" href="/Denot/#19202" class="Bound">z</a><a id="19228" class="Symbol">))</a> <a id="19231" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>

<p>Two terms M and N are denotational equal when their denotations are
equal, that is, ℰ M ≃ ℰ N.</p>

<h2 id="road-map-for-the-following-chapters">Road map for the following chapters</h2>

<p>The subsequent chapters prove that the denotational semantics has
several desirable properties. First, we prove that the semantics is
compositional, i.e., that the denotation of a term is a function of
the denotations of its subterms. To do this we shall prove equations
of the following shape.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ℰ (ƛ M) ≃ ... ℰ M ...
ℰ (M · N) ≃ ... ℰ M ... ℰ N ...
</code></pre></div></div>

<p>The compositionality property is not trivial because the semantics we
have defined includes three rules that are not syntax directed:
(⊥-intro), (⊔-intro), and (sub).</p>

<p>Next we investigate whether the denotational semantics and the
reduction semantics are equivalent. Recall that the job of a language
semantics is to describe the observable behavior of a given program
M. For the lambda calculus there are several choices that one can
make, but they usually boil down to a single bit of information:</p>

<ul>
  <li>divergence: the program M executes forever.</li>
  <li>termination: the program M halts.</li>
</ul>

<p>We can characterize divergence and termination in terms of reduction.</p>

<ul>
  <li>divergence: ¬ (M —↠ ƛ N) for any term N.</li>
  <li>termination: M —↠ ƛ N for some term N.</li>
</ul>

<p>We can also characterize divergence and termination using denotations.</p>

<ul>
  <li>divergence: ¬ (∅ ⊢ M ↓ v ↦ v’) for any v and v’.</li>
  <li>termination: ∅ ⊢ M ↓ v ↦ v’ for some v and v’.</li>
</ul>

<p>Alternatively, we can use the denotation function ℰ.</p>

<ul>
  <li>divergence: ¬ (ℰ M ≃ ℰ (ƛ N)) for any term N.</li>
  <li>termination: ℰ M ≃ ℰ (ƛ N) for some term N.</li>
</ul>

<p>So the question is whether the reduction semantics and denotational
semantics are equivalent.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>(∃ N. M —↠ ƛ N)  iff  (∃ N. ℰ M ≃ ℰ (ƛ N))
</code></pre></div></div>

<p>We address each direction of the equivalence in the second and third
chapters. In the second chapter we prove that reduction to a lambda
abstraction implies denotational equality to a lambda
abstraction. This property is called the <em>soundness</em> in the
literature.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>M —↠ ƛ N  implies  ℰ M ≃ ℰ (ƛ N)
</code></pre></div></div>

<p>In the third chapter we prove that denotational equality to a lambda
abstraction implies reduction to a lambda abstraction. This property
is called <em>adequacy</em> in the literature.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ℰ M ≃ ℰ (ƛ N)  implies M —↠ ƛ N' for some N'
</code></pre></div></div>

<p>The proofs of these properties rely on some basic results about the
denotational semantics, which we establish in the rest of this
chapter.  We start with some lemmas about renaming, which are quite
similar to the renaming lemmas that we have seen in previous chapters.
We conclude with a proof of an important inversion lemma for the
less-than relation regarding function values.</p>

<h2 id="renaming-preserves-denotations">Renaming preserves denotations</h2>

<p>We shall prove that renaming variables, and changing the environment
accordingly, preserves the meaning of a term. We generalize the
renaming lemma to allow the values in the new environment to be the
same or larger than the original values. This generalization is useful
in proving that reduction implies denotational equality.</p>

<p>As before, we need an extension lemma to handle the case where we
proceed underneath a lambda abstraction. Here, the nth function
performs lookup in the environment, analogous to Γ ∋ A.  Now suppose
that ρ is a renaming that maps variables in γ into variables with
equal or larger values in δ. This lemmas says that extending the
renaming producing a renaming (ext r) that maps (γ , v) to (δ , v).</p>

<pre class="Agda"><a id="Rename"></a><a id="22654" href="/Denot/#22654" class="Function">Rename</a> <a id="22661" class="Symbol">:</a> <a id="22663" href="/Untyped/#2980" class="Datatype">Context</a> <a id="22671" class="Symbol">→</a> <a id="22673" href="/Untyped/#2980" class="Datatype">Context</a> <a id="22681" class="Symbol">→</a> <a id="22683" class="PrimitiveType">Set</a>
<a id="22687" href="/Denot/#22654" class="Function">Rename</a> <a id="22694" href="/Denot/#22694" class="Bound">Γ</a> <a id="22696" href="/Denot/#22696" class="Bound">Δ</a> <a id="22698" class="Symbol">=</a> <a id="22700" class="Symbol">∀{</a><a id="22702" href="/Denot/#22702" class="Bound">A</a><a id="22703" class="Symbol">}</a> <a id="22705" class="Symbol">→</a> <a id="22707" href="/Denot/#22694" class="Bound">Γ</a> <a id="22709" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="22711" href="/Denot/#22702" class="Bound">A</a> <a id="22713" class="Symbol">→</a> <a id="22715" href="/Denot/#22696" class="Bound">Δ</a> <a id="22717" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="22719" href="/Denot/#22702" class="Bound">A</a></pre>

<pre class="Agda"><a id="ext-nth"></a><a id="22747" href="/Denot/#22747" class="Function">ext-nth</a> <a id="22755" class="Symbol">:</a> <a id="22757" class="Symbol">∀</a> <a id="22759" class="Symbol">{</a><a id="22760" href="/Denot/#22760" class="Bound">Γ</a> <a id="22762" href="/Denot/#22762" class="Bound">Δ</a> <a id="22764" href="/Denot/#22764" class="Bound">v</a><a id="22765" class="Symbol">}</a> <a id="22767" class="Symbol">{</a><a id="22768" href="/Denot/#22768" class="Bound">γ</a> <a id="22770" class="Symbol">:</a> <a id="22772" href="/Denot/#7488" class="Function">Env</a> <a id="22776" href="/Denot/#22760" class="Bound">Γ</a><a id="22777" class="Symbol">}</a> <a id="22779" class="Symbol">{</a><a id="22780" href="/Denot/#22780" class="Bound">δ</a> <a id="22782" class="Symbol">:</a> <a id="22784" href="/Denot/#7488" class="Function">Env</a> <a id="22788" href="/Denot/#22762" class="Bound">Δ</a><a id="22789" class="Symbol">}</a>
  <a id="22793" class="Symbol">→</a> <a id="22795" class="Symbol">(</a><a id="22796" href="/Denot/#22796" class="Bound">ρ</a> <a id="22798" class="Symbol">:</a> <a id="22800" href="/Denot/#22654" class="Function">Rename</a> <a id="22807" href="/Denot/#22760" class="Bound">Γ</a> <a id="22809" href="/Denot/#22762" class="Bound">Δ</a><a id="22810" class="Symbol">)</a>
  <a id="22814" class="Symbol">→</a> <a id="22816" href="/Denot/#22768" class="Bound">γ</a> <a id="22818" href="/Denot/#8499" class="Function Operator">`⊑</a> <a id="22821" class="Symbol">(</a><a id="22822" href="/Denot/#22780" class="Bound">δ</a> <a id="22824" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">∘</a> <a id="22826" href="/Denot/#22796" class="Bound">ρ</a><a id="22827" class="Symbol">)</a>
    <a id="22833" class="Comment">------------------------------</a>
  <a id="22866" class="Symbol">→</a> <a id="22868" class="Symbol">(</a><a id="22869" href="/Denot/#22768" class="Bound">γ</a> <a id="22871" href="/Denot/#7646" class="Function Operator">`,</a> <a id="22874" href="/Denot/#22764" class="Bound">v</a><a id="22875" class="Symbol">)</a> <a id="22877" href="/Denot/#8499" class="Function Operator">`⊑</a> <a id="22880" class="Symbol">((</a><a id="22882" href="/Denot/#22780" class="Bound">δ</a> <a id="22884" href="/Denot/#7646" class="Function Operator">`,</a> <a id="22887" href="/Denot/#22764" class="Bound">v</a><a id="22888" class="Symbol">)</a> <a id="22890" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">∘</a> <a id="22892" href="/Untyped/#5845" class="Function">ext</a> <a id="22896" href="/Denot/#22796" class="Bound">ρ</a><a id="22897" class="Symbol">)</a>
<a id="22899" href="/Denot/#22747" class="Function">ext-nth</a> <a id="22907" href="/Denot/#22907" class="Bound">ρ</a> <a id="22909" href="/Denot/#22909" class="Bound">lt</a> <a id="22912" href="/Untyped/#3401" class="InductiveConstructor">Z</a> <a id="22914" class="Symbol">=</a> <a id="22916" href="/Denot/#5698" class="Function">Refl⊑</a>
<a id="22922" href="/Denot/#22747" class="Function">ext-nth</a> <a id="22930" href="/Denot/#22930" class="Bound">ρ</a> <a id="22932" href="/Denot/#22932" class="Bound">lt</a> <a id="22935" class="Symbol">(</a><a id="22936" href="/Untyped/#3446" class="InductiveConstructor Operator">S</a> <a id="22938" href="/Denot/#22938" class="Bound">x</a><a id="22939" class="Symbol">)</a> <a id="22941" class="Symbol">=</a> <a id="22943" href="/Denot/#22932" class="Bound">lt</a> <a id="22946" href="/Denot/#22938" class="Bound">x</a></pre>

<p>We proceed by cases on the de Bruijn index n.</p>

<ul>
  <li>
    <p>If it is Z, then we just need to show that v ≡ v, which we have by refl.</p>
  </li>
  <li>
    <p>If it is S n’, then the goal simplifies to nth n’ γ ≡ nth (ρ n’) δ,
which is an instance of the premise.</p>
  </li>
</ul>

<p>Now for the renaming lemma. Suppose we have a renaming that maps
variables in γ into variables with the same values in δ.  If M
results in v when evaluated in environment γ, then applying the
renaming to M produces a program that results in the same value v when
evaluated in δ.</p>

<pre class="Agda"><a id="rename-pres"></a><a id="23486" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23498" class="Symbol">:</a> <a id="23500" class="Symbol">∀</a> <a id="23502" class="Symbol">{</a><a id="23503" href="/Denot/#23503" class="Bound">Γ</a> <a id="23505" href="/Denot/#23505" class="Bound">Δ</a> <a id="23507" href="/Denot/#23507" class="Bound">v</a><a id="23508" class="Symbol">}</a> <a id="23510" class="Symbol">{</a><a id="23511" href="/Denot/#23511" class="Bound">γ</a> <a id="23513" class="Symbol">:</a> <a id="23515" href="/Denot/#7488" class="Function">Env</a> <a id="23519" href="/Denot/#23503" class="Bound">Γ</a><a id="23520" class="Symbol">}</a> <a id="23522" class="Symbol">{</a><a id="23523" href="/Denot/#23523" class="Bound">δ</a> <a id="23525" class="Symbol">:</a> <a id="23527" href="/Denot/#7488" class="Function">Env</a> <a id="23531" href="/Denot/#23505" class="Bound">Δ</a><a id="23532" class="Symbol">}</a> <a id="23534" class="Symbol">{</a><a id="23535" href="/Denot/#23535" class="Bound">M</a> <a id="23537" class="Symbol">:</a> <a id="23539" href="/Denot/#23503" class="Bound">Γ</a> <a id="23541" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="23543" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="23544" class="Symbol">}</a>
  <a id="23548" class="Symbol">→</a> <a id="23550" class="Symbol">(</a><a id="23551" href="/Denot/#23551" class="Bound">ρ</a> <a id="23553" class="Symbol">:</a> <a id="23555" href="/Denot/#22654" class="Function">Rename</a> <a id="23562" href="/Denot/#23503" class="Bound">Γ</a> <a id="23564" href="/Denot/#23505" class="Bound">Δ</a><a id="23565" class="Symbol">)</a>
  <a id="23569" class="Symbol">→</a> <a id="23571" href="/Denot/#23511" class="Bound">γ</a> <a id="23573" href="/Denot/#8499" class="Function Operator">`⊑</a> <a id="23576" class="Symbol">(</a><a id="23577" href="/Denot/#23523" class="Bound">δ</a> <a id="23579" href="https://agda.github.io/agda-stdlib/Function.html#769" class="Function Operator">∘</a> <a id="23581" href="/Denot/#23551" class="Bound">ρ</a><a id="23582" class="Symbol">)</a>
  <a id="23586" class="Symbol">→</a> <a id="23588" href="/Denot/#23511" class="Bound">γ</a> <a id="23590" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="23592" href="/Denot/#23535" class="Bound">M</a> <a id="23594" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="23596" href="/Denot/#23507" class="Bound">v</a>
    <a id="23602" class="Comment">---------------------</a>
  <a id="23626" class="Symbol">→</a> <a id="23628" href="/Denot/#23523" class="Bound">δ</a> <a id="23630" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="23632" class="Symbol">(</a><a id="23633" href="/Untyped/#6171" class="Function">rename</a> <a id="23640" href="/Denot/#23551" class="Bound">ρ</a> <a id="23642" href="/Denot/#23535" class="Bound">M</a><a id="23643" class="Symbol">)</a> <a id="23645" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="23647" href="/Denot/#23507" class="Bound">v</a>
<a id="23649" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23661" href="/Denot/#23661" class="Bound">ρ</a> <a id="23663" href="/Denot/#23663" class="Bound">lt</a> <a id="23666" class="Symbol">(</a><a id="23667" href="/Denot/#10045" class="InductiveConstructor">var</a> <a id="23671" class="Symbol">{</a><a id="23672" class="Argument">x</a> <a id="23674" class="Symbol">=</a> <a id="23676" href="/Denot/#23676" class="Bound">x</a><a id="23677" class="Symbol">})</a> <a id="23680" class="Symbol">=</a> <a id="23682" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="23686" href="/Denot/#10045" class="InductiveConstructor">var</a> <a id="23690" class="Symbol">(</a><a id="23691" href="/Denot/#23663" class="Bound">lt</a> <a id="23694" href="/Denot/#23676" class="Bound">x</a><a id="23695" class="Symbol">)</a>
<a id="23697" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23709" href="/Denot/#23709" class="Bound">ρ</a> <a id="23711" href="/Denot/#23711" class="Bound">lt</a> <a id="23714" class="Symbol">(</a><a id="23715" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="23722" href="/Denot/#23722" class="Bound">d</a> <a id="23724" href="/Denot/#23724" class="Bound">d₁</a><a id="23726" class="Symbol">)</a> <a id="23728" class="Symbol">=</a>
   <a id="23733" href="/Denot/#10128" class="InductiveConstructor">↦-elim</a> <a id="23740" class="Symbol">(</a><a id="23741" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23753" href="/Denot/#23709" class="Bound">ρ</a> <a id="23755" href="/Denot/#23711" class="Bound">lt</a> <a id="23758" href="/Denot/#23722" class="Bound">d</a><a id="23759" class="Symbol">)</a> <a id="23761" class="Symbol">(</a><a id="23762" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23774" href="/Denot/#23709" class="Bound">ρ</a> <a id="23776" href="/Denot/#23711" class="Bound">lt</a> <a id="23779" href="/Denot/#23724" class="Bound">d₁</a><a id="23781" class="Symbol">)</a> 
<a id="23784" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23796" href="/Denot/#23796" class="Bound">ρ</a> <a id="23798" href="/Denot/#23798" class="Bound">lt</a> <a id="23801" class="Symbol">(</a><a id="23802" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="23810" href="/Denot/#23810" class="Bound">d</a><a id="23811" class="Symbol">)</a> <a id="23813" class="Symbol">=</a>
   <a id="23818" href="/Denot/#10281" class="InductiveConstructor">↦-intro</a> <a id="23826" class="Symbol">(</a><a id="23827" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23839" class="Symbol">(</a><a id="23840" href="/Untyped/#5845" class="Function">ext</a> <a id="23844" href="/Denot/#23796" class="Bound">ρ</a><a id="23845" class="Symbol">)</a> <a id="23847" class="Symbol">(</a><a id="23848" href="/Denot/#22747" class="Function">ext-nth</a> <a id="23856" href="/Denot/#23796" class="Bound">ρ</a> <a id="23858" href="/Denot/#23798" class="Bound">lt</a><a id="23860" class="Symbol">)</a> <a id="23862" href="/Denot/#23810" class="Bound">d</a><a id="23863" class="Symbol">)</a>
<a id="23865" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23877" href="/Denot/#23877" class="Bound">ρ</a> <a id="23879" href="/Denot/#23879" class="Bound">lt</a> <a id="23882" href="/Denot/#10413" class="InductiveConstructor">⊥-intro</a> <a id="23890" class="Symbol">=</a> <a id="23892" href="/Denot/#10413" class="InductiveConstructor">⊥-intro</a>
<a id="23900" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23912" href="/Denot/#23912" class="Bound">ρ</a> <a id="23914" href="/Denot/#23914" class="Bound">lt</a> <a id="23917" class="Symbol">(</a><a id="23918" href="/Denot/#10488" class="InductiveConstructor">⊔-intro</a> <a id="23926" href="/Denot/#23926" class="Bound">d</a> <a id="23928" href="/Denot/#23928" class="Bound">d₁</a><a id="23930" class="Symbol">)</a> <a id="23932" class="Symbol">=</a>
   <a id="23937" href="/Denot/#10488" class="InductiveConstructor">⊔-intro</a> <a id="23945" class="Symbol">(</a><a id="23946" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23958" href="/Denot/#23912" class="Bound">ρ</a> <a id="23960" href="/Denot/#23914" class="Bound">lt</a> <a id="23963" href="/Denot/#23926" class="Bound">d</a><a id="23964" class="Symbol">)</a> <a id="23966" class="Symbol">(</a><a id="23967" href="/Denot/#23486" class="Function">rename-pres</a> <a id="23979" href="/Denot/#23912" class="Bound">ρ</a> <a id="23981" href="/Denot/#23914" class="Bound">lt</a> <a id="23984" href="/Denot/#23928" class="Bound">d₁</a><a id="23986" class="Symbol">)</a>
<a id="23988" href="/Denot/#23486" class="Function">rename-pres</a> <a id="24000" href="/Denot/#24000" class="Bound">ρ</a> <a id="24002" href="/Denot/#24002" class="Bound">lt</a> <a id="24005" class="Symbol">(</a><a id="24006" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="24010" href="/Denot/#24010" class="Bound">d</a> <a id="24012" href="/Denot/#24012" class="Bound">lt′</a><a id="24015" class="Symbol">)</a> <a id="24017" class="Symbol">=</a>
   <a id="24022" href="/Denot/#10632" class="InductiveConstructor">sub</a> <a id="24026" class="Symbol">(</a><a id="24027" href="/Denot/#23486" class="Function">rename-pres</a> <a id="24039" href="/Denot/#24000" class="Bound">ρ</a> <a id="24041" href="/Denot/#24002" class="Bound">lt</a> <a id="24044" href="/Denot/#24010" class="Bound">d</a><a id="24045" class="Symbol">)</a> <a id="24047" href="/Denot/#24012" class="Bound">lt′</a></pre>

<p>The proof is by induction on the semantics of M.  As you can see, all
of the cases are trivial except the cases for variables and lambda.</p>

<ul>
  <li>
    <p>For a variable x, we make use of the premise to
show that nth x γ ≡ nth (ρ x) δ.</p>
  </li>
  <li>
    <p>For a lambda abstraction, the induction hypothesis requires us to
extend the renaming. We do so, and use the ext-nth lemma to show
that the extended renaming maps variables to ones with equivalent
values.</p>
  </li>
</ul>

<h2 id="identity-renamings-and-environment-strengthening">Identity renamings and environment strengthening</h2>

<p>We shall need a corollary of the renaming lemma that says that if M
results in v, then we can replace a value in the environment with a
larger one (a stronger one), and M still results in v. In particular,
if γ ⊢ M ↓ v and γ `⊑ δ, then δ ⊢ M ↓ v.  What does this have to do
with renaming?  It’s renaming with the identity function.</p>

<p>The next lemma shows that renaming with an identity function is indeed
an identity function on terms. In the case of lambda abstraction, the
identity function gets extended, becoming another identity function,
but not the same one (Agda lacks extensionality).  To work around this
issue, we parameterize the proof over any function that is an
identity.</p>

<pre class="Agda"><a id="is-identity"></a><a id="25256" href="/Denot/#25256" class="Function">is-identity</a> <a id="25268" class="Symbol">:</a> <a id="25270" class="Symbol">∀</a> <a id="25272" class="Symbol">{</a><a id="25273" href="/Denot/#25273" class="Bound">Γ</a><a id="25274" class="Symbol">}</a> <a id="25276" class="Symbol">(</a><a id="25277" href="/Denot/#25277" class="Bound">id</a> <a id="25280" class="Symbol">:</a> <a id="25282" class="Symbol">∀{</a><a id="25284" href="/Denot/#25284" class="Bound">A</a><a id="25285" class="Symbol">}</a> <a id="25287" class="Symbol">→</a> <a id="25289" href="/Denot/#25273" class="Bound">Γ</a> <a id="25291" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="25293" href="/Denot/#25284" class="Bound">A</a> <a id="25295" class="Symbol">→</a> <a id="25297" href="/Denot/#25273" class="Bound">Γ</a> <a id="25299" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="25301" href="/Denot/#25284" class="Bound">A</a><a id="25302" class="Symbol">)</a> <a id="25304" class="Symbol">→</a> <a id="25306" class="PrimitiveType">Set</a>
<a id="25310" href="/Denot/#25256" class="Function">is-identity</a> <a id="25322" class="Symbol">{</a><a id="25323" href="/Denot/#25323" class="Bound">Γ</a><a id="25324" class="Symbol">}</a> <a id="25326" href="/Denot/#25326" class="Bound">id</a> <a id="25329" class="Symbol">=</a> <a id="25331" class="Symbol">(∀</a> <a id="25334" class="Symbol">{</a><a id="25335" href="/Denot/#25335" class="Bound">x</a> <a id="25337" class="Symbol">:</a> <a id="25339" href="/Denot/#25323" class="Bound">Γ</a> <a id="25341" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="25343" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="25344" class="Symbol">}</a> <a id="25346" class="Symbol">→</a> <a id="25348" href="/Denot/#25326" class="Bound">id</a> <a id="25351" class="Symbol">{</a><a id="25352" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="25353" class="Symbol">}</a> <a id="25355" href="/Denot/#25335" class="Bound">x</a> <a id="25357" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="25359" href="/Denot/#25335" class="Bound">x</a><a id="25360" class="Symbol">)</a></pre>

<pre class="Agda"><a id="rename-id"></a><a id="25387" href="/Denot/#25387" class="Function">rename-id</a> <a id="25397" class="Symbol">:</a> <a id="25399" class="Symbol">∀</a> <a id="25401" class="Symbol">{</a><a id="25402" href="/Denot/#25402" class="Bound">Γ</a><a id="25403" class="Symbol">}</a> <a id="25405" class="Symbol">{</a><a id="25406" href="/Denot/#25406" class="Bound">M</a> <a id="25408" class="Symbol">:</a> <a id="25410" href="/Denot/#25402" class="Bound">Γ</a> <a id="25412" href="/Untyped/#4150" class="Datatype Operator">⊢</a> <a id="25414" href="/Untyped/#2694" class="InductiveConstructor">★</a><a id="25415" class="Symbol">}</a> <a id="25417" class="Symbol">{</a><a id="25418" href="/Denot/#25418" class="Bound">id</a> <a id="25421" class="Symbol">:</a> <a id="25423" class="Symbol">∀{</a><a id="25425" href="/Denot/#25425" class="Bound">A</a><a id="25426" class="Symbol">}</a> <a id="25428" class="Symbol">→</a> <a id="25430" href="/Denot/#25402" class="Bound">Γ</a> <a id="25432" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="25434" href="/Denot/#25425" class="Bound">A</a> <a id="25436" class="Symbol">→</a> <a id="25438" href="/Denot/#25402" class="Bound">Γ</a> <a id="25440" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="25442" href="/Denot/#25425" class="Bound">A</a><a id="25443" class="Symbol">}</a>
  <a id="25447" class="Symbol">→</a> <a id="25449" href="/Denot/#25256" class="Function">is-identity</a> <a id="25461" href="/Denot/#25418" class="Bound">id</a>
    <a id="25468" class="Comment">---------------</a>
  <a id="25486" class="Symbol">→</a> <a id="25488" href="/Untyped/#6171" class="Function">rename</a> <a id="25495" href="/Denot/#25418" class="Bound">id</a> <a id="25498" href="/Denot/#25406" class="Bound">M</a> <a id="25500" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="25502" href="/Denot/#25406" class="Bound">M</a>
<a id="25504" href="/Denot/#25387" class="Function">rename-id</a> <a id="25514" class="Symbol">{</a><a id="25515" class="Argument">M</a> <a id="25517" class="Symbol">=</a> <a id="25519" href="/Untyped/#4186" class="InductiveConstructor Operator">`</a> <a id="25521" href="/Denot/#25521" class="Bound">x</a><a id="25522" class="Symbol">}</a> <a id="25524" href="/Denot/#25524" class="Bound">eq</a> <a id="25527" class="Symbol">=</a> <a id="25529" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="25534" href="/Untyped/#4186" class="InductiveConstructor Operator">`_</a> <a id="25537" class="Symbol">(</a><a id="25538" href="/Denot/#25524" class="Bound">eq</a> <a id="25541" class="Symbol">{</a><a id="25542" href="/Denot/#25521" class="Bound">x</a><a id="25543" class="Symbol">})</a>
<a id="25546" href="/Denot/#25387" class="Function">rename-id</a> <a id="25556" class="Symbol">{</a><a id="25557" class="Argument">M</a> <a id="25559" class="Symbol">=</a> <a id="25561" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ</a> <a id="25563" href="/Denot/#25563" class="Bound">M₁</a><a id="25565" class="Symbol">}{</a><a id="25567" class="Argument">id</a> <a id="25570" class="Symbol">=</a> <a id="25572" href="/Denot/#25572" class="Bound">id</a><a id="25574" class="Symbol">}</a> <a id="25576" href="/Denot/#25576" class="Bound">eq</a> <a id="25579" class="Symbol">=</a> <a id="25581" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="25586" href="/Untyped/#4238" class="InductiveConstructor Operator">ƛ_</a> <a id="25589" class="Symbol">(</a><a id="25590" href="/Denot/#25387" class="Function">rename-id</a> <a id="25600" class="Symbol">{</a><a id="25601" class="Argument">M</a> <a id="25603" class="Symbol">=</a> <a id="25605" href="/Denot/#25563" class="Bound">M₁</a><a id="25607" class="Symbol">}</a> <a id="25609" href="/Denot/#25627" class="Function">ext-id</a><a id="25615" class="Symbol">)</a>
  <a id="25619" class="Keyword">where</a>
  <a id="25627" href="/Denot/#25627" class="Function">ext-id</a> <a id="25634" class="Symbol">:</a> <a id="25636" href="/Denot/#25256" class="Function">is-identity</a> <a id="25648" class="Symbol">(</a><a id="25649" href="/Untyped/#5845" class="Function">ext</a> <a id="25653" href="/Denot/#25572" class="Bound">id</a><a id="25655" class="Symbol">)</a>
  <a id="25659" href="/Denot/#25627" class="Function">ext-id</a> <a id="25666" class="Symbol">{</a><a id="25667" href="/Untyped/#3401" class="InductiveConstructor">Z</a><a id="25668" class="Symbol">}</a> <a id="25670" class="Symbol">=</a> <a id="25672" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
  <a id="25679" href="/Denot/#25627" class="Function">ext-id</a> <a id="25686" class="Symbol">{</a><a id="25687" href="/Untyped/#3446" class="InductiveConstructor Operator">S</a> <a id="25689" href="/Denot/#25689" class="Bound">x</a><a id="25690" class="Symbol">}</a> <a id="25692" class="Symbol">=</a> <a id="25694" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1170" class="Function">cong</a> <a id="25699" href="/Untyped/#3446" class="InductiveConstructor Operator">S_</a> <a id="25702" href="/Denot/#25576" class="Bound">eq</a>
<a id="25705" href="/Denot/#25387" class="Function">rename-id</a> <a id="25715" class="Symbol">{</a><a id="25716" class="Argument">M</a> <a id="25718" class="Symbol">=</a> <a id="25720" href="/Denot/#25720" class="Bound">M</a> <a id="25722" href="/Untyped/#4298" class="InductiveConstructor Operator">·</a> <a id="25724" href="/Denot/#25724" class="Bound">M₁</a><a id="25726" class="Symbol">}</a> <a id="25728" href="/Denot/#25728" class="Bound">eq</a> <a id="25731" class="Symbol">=</a> <a id="25733" href="https://agda.github.io/agda-stdlib/Relation.Binary.PropositionalEquality.html#1408" class="Function">cong₂</a> <a id="25739" href="/Untyped/#4298" class="InductiveConstructor Operator">_·_</a> <a id="25743" class="Symbol">(</a><a id="25744" href="/Denot/#25387" class="Function">rename-id</a> <a id="25754" href="/Denot/#25728" class="Bound">eq</a><a id="25756" class="Symbol">)</a> <a id="25758" class="Symbol">(</a><a id="25759" href="/Denot/#25387" class="Function">rename-id</a> <a id="25769" href="/Denot/#25728" class="Bound">eq</a><a id="25771" class="Symbol">)</a></pre>

<p>The identity function on variables, var-id, is an identity function.</p>

<pre class="Agda"><a id="var-id"></a><a id="25868" href="/Denot/#25868" class="Function">var-id</a> <a id="25875" class="Symbol">:</a> <a id="25877" class="Symbol">∀</a> <a id="25879" class="Symbol">{</a><a id="25880" href="/Denot/#25880" class="Bound">Γ</a> <a id="25882" href="/Denot/#25882" class="Bound">A</a><a id="25883" class="Symbol">}</a> <a id="25885" class="Symbol">→</a> <a id="25887" class="Symbol">(</a><a id="25888" href="/Denot/#25880" class="Bound">Γ</a> <a id="25890" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="25892" href="/Denot/#25882" class="Bound">A</a><a id="25893" class="Symbol">)</a> <a id="25895" class="Symbol">→</a> <a id="25897" class="Symbol">(</a><a id="25898" href="/Denot/#25880" class="Bound">Γ</a> <a id="25900" href="/Untyped/#3365" class="Datatype Operator">∋</a> <a id="25902" href="/Denot/#25882" class="Bound">A</a><a id="25903" class="Symbol">)</a>
<a id="25905" href="/Denot/#25868" class="Function">var-id</a> <a id="25912" class="Symbol">{</a><a id="25913" href="/Denot/#25913" class="Bound">A</a><a id="25914" class="Symbol">}</a> <a id="25916" href="/Denot/#25916" class="Bound">x</a> <a id="25918" class="Symbol">=</a> <a id="25920" href="/Denot/#25916" class="Bound">x</a>

<a id="var-id-id"></a><a id="25923" href="/Denot/#25923" class="Function">var-id-id</a> <a id="25933" class="Symbol">:</a> <a id="25935" class="Symbol">∀</a> <a id="25937" class="Symbol">{</a><a id="25938" href="/Denot/#25938" class="Bound">Γ</a><a id="25939" class="Symbol">}</a> <a id="25941" class="Symbol">→</a> <a id="25943" href="/Denot/#25256" class="Function">is-identity</a> <a id="25955" class="Symbol">{</a><a id="25956" href="/Denot/#25938" class="Bound">Γ</a><a id="25957" class="Symbol">}</a> <a id="25959" href="/Denot/#25868" class="Function">var-id</a>
<a id="25966" href="/Denot/#25923" class="Function">var-id-id</a> <a id="25976" class="Symbol">=</a> <a id="25978" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<p>We can now prove environment strengthening by applying the renaming
lemma with the identity renaming, which gives us δ ⊢ rename var-id M ↓
v, and then we apply the rename-id lemma to obtain δ ⊢ M ↓ v.</p>

<pre class="Agda"><a id="Env⊑"></a><a id="26210" href="/Denot/#26210" class="Function">Env⊑</a> <a id="26215" class="Symbol">:</a> <a id="26217" class="Symbol">∀</a> <a id="26219" class="Symbol">{</a><a id="26220" href="/Denot/#26220" class="Bound">Γ</a><a id="26221" class="Symbol">}</a> <a id="26223" class="Symbol">{</a><a id="26224" href="/Denot/#26224" class="Bound">γ</a> <a id="26226" class="Symbol">:</a> <a id="26228" href="/Denot/#7488" class="Function">Env</a> <a id="26232" href="/Denot/#26220" class="Bound">Γ</a><a id="26233" class="Symbol">}</a> <a id="26235" class="Symbol">{</a><a id="26236" href="/Denot/#26236" class="Bound">δ</a> <a id="26238" class="Symbol">:</a> <a id="26240" href="/Denot/#7488" class="Function">Env</a> <a id="26244" href="/Denot/#26220" class="Bound">Γ</a><a id="26245" class="Symbol">}</a> <a id="26247" class="Symbol">{</a><a id="26248" href="/Denot/#26248" class="Bound">M</a> <a id="26250" href="/Denot/#26250" class="Bound">v</a><a id="26251" class="Symbol">}</a>
  <a id="26255" class="Symbol">→</a> <a id="26257" href="/Denot/#26224" class="Bound">γ</a> <a id="26259" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="26261" href="/Denot/#26248" class="Bound">M</a> <a id="26263" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="26265" href="/Denot/#26250" class="Bound">v</a>
  <a id="26269" class="Symbol">→</a> <a id="26271" href="/Denot/#26224" class="Bound">γ</a> <a id="26273" href="/Denot/#8499" class="Function Operator">`⊑</a> <a id="26276" href="/Denot/#26236" class="Bound">δ</a>
    <a id="26282" class="Comment">----------</a>
  <a id="26295" class="Symbol">→</a> <a id="26297" href="/Denot/#26236" class="Bound">δ</a> <a id="26299" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="26301" href="/Denot/#26248" class="Bound">M</a> <a id="26303" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="26305" href="/Denot/#26250" class="Bound">v</a>
<a id="26307" href="/Denot/#26210" class="Function">Env⊑</a><a id="26311" class="Symbol">{</a><a id="26312" href="/Denot/#26312" class="Bound">Γ</a><a id="26313" class="Symbol">}{</a><a id="26315" href="/Denot/#26315" class="Bound">γ</a><a id="26316" class="Symbol">}{</a><a id="26318" href="/Denot/#26318" class="Bound">δ</a><a id="26319" class="Symbol">}{</a><a id="26321" href="/Denot/#26321" class="Bound">M</a><a id="26322" class="Symbol">}{</a><a id="26324" href="/Denot/#26324" class="Bound">v</a><a id="26325" class="Symbol">}</a> <a id="26327" href="/Denot/#26327" class="Bound">d</a> <a id="26329" href="/Denot/#26329" class="Bound">lt</a>
      <a id="26338" class="Keyword">with</a> <a id="26343" href="/Denot/#23486" class="Function">rename-pres</a> <a id="26355" href="/Denot/#25868" class="Function">var-id</a> <a id="26362" href="/Denot/#26329" class="Bound">lt</a> <a id="26365" href="/Denot/#26327" class="Bound">d</a>
<a id="26367" class="Symbol">...</a> <a id="26371" class="Symbol">|</a> <a id="26373" href="/Denot/#26373" class="Bound">d&#39;</a> <a id="26376" class="Keyword">rewrite</a> <a id="26384" href="/Denot/#25387" class="Function">rename-id</a> <a id="26394" class="Symbol">{</a><a id="26395" class="Bound">Γ</a><a id="26396" class="Symbol">}{</a><a id="26398" class="Bound">M</a><a id="26399" class="Symbol">}{</a><a id="26401" href="/Denot/#25868" class="Function">var-id</a><a id="26407" class="Symbol">}</a> <a id="26409" class="Symbol">(</a><a id="26410" href="/Denot/#25923" class="Function">var-id-id</a> <a id="26420" class="Symbol">{</a><a id="26421" class="Bound">Γ</a><a id="26422" class="Symbol">})</a> <a id="26425" class="Symbol">=</a> <a id="26427" href="/Denot/#26373" class="Bound">d&#39;</a></pre>

<p>In the proof that substitution reflects denotations, in the case for
lambda abstraction, we use a minor variation of Env⊑, in which just
the last element of the environment gets larger.</p>

<pre class="Agda"><a id="up-env"></a><a id="26642" href="/Denot/#26642" class="Function">up-env</a> <a id="26649" class="Symbol">:</a> <a id="26651" class="Symbol">∀</a> <a id="26653" class="Symbol">{</a><a id="26654" href="/Denot/#26654" class="Bound">Γ</a><a id="26655" class="Symbol">}</a> <a id="26657" class="Symbol">{</a><a id="26658" href="/Denot/#26658" class="Bound">γ</a> <a id="26660" class="Symbol">:</a> <a id="26662" href="/Denot/#7488" class="Function">Env</a> <a id="26666" href="/Denot/#26654" class="Bound">Γ</a><a id="26667" class="Symbol">}</a> <a id="26669" class="Symbol">{</a><a id="26670" href="/Denot/#26670" class="Bound">M</a> <a id="26672" href="/Denot/#26672" class="Bound">v</a> <a id="26674" href="/Denot/#26674" class="Bound">u₁</a> <a id="26677" href="/Denot/#26677" class="Bound">u₂</a><a id="26679" class="Symbol">}</a>
  <a id="26683" class="Symbol">→</a> <a id="26685" class="Symbol">(</a><a id="26686" href="/Denot/#26658" class="Bound">γ</a> <a id="26688" href="/Denot/#7646" class="Function Operator">`,</a> <a id="26691" href="/Denot/#26674" class="Bound">u₁</a><a id="26693" class="Symbol">)</a> <a id="26695" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="26697" href="/Denot/#26670" class="Bound">M</a> <a id="26699" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="26701" href="/Denot/#26672" class="Bound">v</a>
  <a id="26705" class="Symbol">→</a> <a id="26707" href="/Denot/#26674" class="Bound">u₁</a> <a id="26710" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="26712" href="/Denot/#26677" class="Bound">u₂</a>
    <a id="26719" class="Comment">-----------------</a>
  <a id="26739" class="Symbol">→</a> <a id="26741" class="Symbol">(</a><a id="26742" href="/Denot/#26658" class="Bound">γ</a> <a id="26744" href="/Denot/#7646" class="Function Operator">`,</a> <a id="26747" href="/Denot/#26677" class="Bound">u₂</a><a id="26749" class="Symbol">)</a> <a id="26751" href="/Denot/#9991" class="Datatype Operator">⊢</a> <a id="26753" href="/Denot/#26670" class="Bound">M</a> <a id="26755" href="/Denot/#9991" class="Datatype Operator">↓</a> <a id="26757" href="/Denot/#26672" class="Bound">v</a>
<a id="26759" href="/Denot/#26642" class="Function">up-env</a> <a id="26766" href="/Denot/#26766" class="Bound">d</a> <a id="26768" href="/Denot/#26768" class="Bound">lt</a> <a id="26771" class="Symbol">=</a> <a id="26773" href="/Denot/#26210" class="Function">Env⊑</a> <a id="26778" href="/Denot/#26766" class="Bound">d</a> <a id="26780" class="Symbol">(</a><a id="26781" href="/Denot/#26802" class="Function">nth-le</a> <a id="26788" href="/Denot/#26768" class="Bound">lt</a><a id="26790" class="Symbol">)</a>
  <a id="26794" class="Keyword">where</a>
  <a id="26802" href="/Denot/#26802" class="Function">nth-le</a> <a id="26809" class="Symbol">:</a> <a id="26811" class="Symbol">∀</a> <a id="26813" class="Symbol">{</a><a id="26814" href="/Denot/#26814" class="Bound">γ</a> <a id="26816" href="/Denot/#26816" class="Bound">u₁</a> <a id="26819" href="/Denot/#26819" class="Bound">u₂</a><a id="26821" class="Symbol">}</a> <a id="26823" class="Symbol">→</a> <a id="26825" href="/Denot/#26816" class="Bound">u₁</a> <a id="26828" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="26830" href="/Denot/#26819" class="Bound">u₂</a> <a id="26833" class="Symbol">→</a> <a id="26835" class="Symbol">(</a><a id="26836" href="/Denot/#26814" class="Bound">γ</a> <a id="26838" href="/Denot/#7646" class="Function Operator">`,</a> <a id="26841" href="/Denot/#26816" class="Bound">u₁</a><a id="26843" class="Symbol">)</a> <a id="26845" href="/Denot/#8499" class="Function Operator">`⊑</a> <a id="26848" class="Symbol">(</a><a id="26849" href="/Denot/#26814" class="Bound">γ</a> <a id="26851" href="/Denot/#7646" class="Function Operator">`,</a> <a id="26854" href="/Denot/#26819" class="Bound">u₂</a><a id="26856" class="Symbol">)</a>
  <a id="26860" href="/Denot/#26802" class="Function">nth-le</a> <a id="26867" href="/Denot/#26867" class="Bound">lt</a> <a id="26870" href="/Untyped/#3401" class="InductiveConstructor">Z</a> <a id="26872" class="Symbol">=</a> <a id="26874" href="/Denot/#26867" class="Bound">lt</a>
  <a id="26879" href="/Denot/#26802" class="Function">nth-le</a> <a id="26886" href="/Denot/#26886" class="Bound">lt</a> <a id="26889" class="Symbol">(</a><a id="26890" href="/Untyped/#3446" class="InductiveConstructor Operator">S</a> <a id="26892" href="/Denot/#26892" class="Bound">n</a><a id="26893" class="Symbol">)</a> <a id="26895" class="Symbol">=</a> <a id="26897" href="/Denot/#5698" class="Function">Refl⊑</a></pre>

<h2 id="inversion-of-the-less-than-relation-for-functions">Inversion of the less-than relation for functions</h2>

<p>What can we deduce from knowing that a function v₁ ↦ v₁’ is less than
some value v₂?  What can we deduce about v₂? The answer to this
question is called the inversion property of less-than for functions.
This question is not easy to answer because of the Dist⊑ rule, which
relates a function on the left to a pair of functions on the right.
So v₂ may include several functions that, as a group, relate to v₁ ↦
v₁’. Furthermore, because of the rules ConjR1⊑ and ConjR2⊑, there may
be other values inside v₂, such as ⊥, that have nothing to do with v₁
↦ v₁’. But in general, we can deduce that v₂ includes a collection of
functions where the join of their domains is less than v₁ and the join
of their codomains is greater than v₁’.</p>

<p>To precisely state and prove this inversion property, we need to
define what it means for a value to <em>include</em> a collection of values.
We also need to define how to compute the join of their domains and
codomains.</p>

<h3 id="value-membership-and-inclusion">Value membership and inclusion</h3>

<p>Recall that we think of a value as a set of entries with the join
operator v₁ ⊔ v₂ acting like set union. The function value v ↦ v’ and
bottom value ⊥ constitute the two kinds of elements of the set.  (In
other contexts one can instead think of ⊥ as the empty set, but here
we must think of it as an element.)  We write v ∈ v’ to say that v is
an element of v’, as defined below.</p>

<pre class="Agda"><a id="28348" class="Keyword">infix</a> <a id="28354" class="Number">5</a> <a id="28356" href="/Denot/#28361" class="Function Operator">_∈_</a>

<a id="_∈_"></a><a id="28361" href="/Denot/#28361" class="Function Operator">_∈_</a> <a id="28365" class="Symbol">:</a> <a id="28367" href="/Denot/#4101" class="Datatype">Value</a> <a id="28373" class="Symbol">→</a> <a id="28375" href="/Denot/#4101" class="Datatype">Value</a> <a id="28381" class="Symbol">→</a> <a id="28383" class="PrimitiveType">Set</a>
<a id="28387" href="/Denot/#28387" class="Bound">v</a> <a id="28389" href="/Denot/#28361" class="Function Operator">∈</a> <a id="28391" href="/Denot/#4121" class="InductiveConstructor">⊥</a> <a id="28393" class="Symbol">=</a> <a id="28395" href="/Denot/#28387" class="Bound">v</a> <a id="28397" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="28399" href="/Denot/#4121" class="InductiveConstructor">⊥</a>
<a id="28401" href="/Denot/#28401" class="Bound">v</a> <a id="28403" href="/Denot/#28361" class="Function Operator">∈</a> <a id="28405" href="/Denot/#28405" class="Bound">v₁</a> <a id="28408" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="28410" href="/Denot/#28410" class="Bound">v₂</a> <a id="28413" class="Symbol">=</a> <a id="28415" href="/Denot/#28401" class="Bound">v</a> <a id="28417" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="28419" href="/Denot/#28405" class="Bound">v₁</a> <a id="28422" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="28424" href="/Denot/#28410" class="Bound">v₂</a>
<a id="28427" href="/Denot/#28427" class="Bound">v</a> <a id="28429" href="/Denot/#28361" class="Function Operator">∈</a> <a id="28431" class="Symbol">(</a><a id="28432" href="/Denot/#28432" class="Bound">v₁</a> <a id="28435" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="28437" href="/Denot/#28437" class="Bound">v₂</a><a id="28439" class="Symbol">)</a> <a id="28441" class="Symbol">=</a> <a id="28443" href="/Denot/#28427" class="Bound">v</a> <a id="28445" href="/Denot/#28361" class="Function Operator">∈</a> <a id="28447" href="/Denot/#28432" class="Bound">v₁</a> <a id="28450" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">⊎</a> <a id="28452" href="/Denot/#28427" class="Bound">v</a> <a id="28454" href="/Denot/#28361" class="Function Operator">∈</a> <a id="28456" href="/Denot/#28437" class="Bound">v₂</a></pre>

<p>So we can represent a collection of values simply as a value.  We
write v₁ ⊆ v₂ to say that all the elements of v₁ are also in v₂.</p>

<pre class="Agda"><a id="28616" class="Keyword">infix</a> <a id="28622" class="Number">5</a> <a id="28624" href="/Denot/#28629" class="Function Operator">_⊆_</a>

<a id="_⊆_"></a><a id="28629" href="/Denot/#28629" class="Function Operator">_⊆_</a> <a id="28633" class="Symbol">:</a> <a id="28635" href="/Denot/#4101" class="Datatype">Value</a> <a id="28641" class="Symbol">→</a> <a id="28643" href="/Denot/#4101" class="Datatype">Value</a> <a id="28649" class="Symbol">→</a> <a id="28651" class="PrimitiveType">Set</a>
<a id="28655" href="/Denot/#28655" class="Bound">v₁</a> <a id="28658" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="28660" href="/Denot/#28660" class="Bound">v₂</a> <a id="28663" class="Symbol">=</a> <a id="28665" class="Symbol">∀{</a><a id="28667" href="/Denot/#28667" class="Bound">v₃</a><a id="28669" class="Symbol">}</a> <a id="28671" class="Symbol">→</a> <a id="28673" href="/Denot/#28667" class="Bound">v₃</a> <a id="28676" href="/Denot/#28361" class="Function Operator">∈</a> <a id="28678" href="/Denot/#28655" class="Bound">v₁</a> <a id="28681" class="Symbol">→</a> <a id="28683" href="/Denot/#28667" class="Bound">v₃</a> <a id="28686" href="/Denot/#28361" class="Function Operator">∈</a> <a id="28688" href="/Denot/#28660" class="Bound">v₂</a></pre>

<p>The notions of membership and inclusion for values are closely related
to the less-than relation. They are narrower relations in that they
imply the less-than relation but not the other way around.</p>

<pre class="Agda"><a id="∈→⊑"></a><a id="28915" href="/Denot/#28915" class="Function">∈→⊑</a> <a id="28919" class="Symbol">:</a> <a id="28921" class="Symbol">∀{</a><a id="28923" href="/Denot/#28923" class="Bound">v₁</a> <a id="28926" href="/Denot/#28926" class="Bound">v₂</a> <a id="28929" class="Symbol">:</a> <a id="28931" href="/Denot/#4101" class="Datatype">Value</a><a id="28936" class="Symbol">}</a>
    <a id="28942" class="Symbol">→</a> <a id="28944" href="/Denot/#28923" class="Bound">v₁</a> <a id="28947" href="/Denot/#28361" class="Function Operator">∈</a> <a id="28949" href="/Denot/#28926" class="Bound">v₂</a>
      <a id="28958" class="Comment">-----</a>
    <a id="28968" class="Symbol">→</a> <a id="28970" href="/Denot/#28923" class="Bound">v₁</a> <a id="28973" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="28975" href="/Denot/#28926" class="Bound">v₂</a>
<a id="28978" href="/Denot/#28915" class="Function">∈→⊑</a> <a id="28982" class="Symbol">{</a><a id="28983" class="DottedPattern Symbol">.</a><a id="28984" href="/Denot/#4121" class="DottedPattern InductiveConstructor">⊥</a><a id="28985" class="Symbol">}</a> <a id="28987" class="Symbol">{</a><a id="28988" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="28989" class="Symbol">}</a> <a id="28991" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="28996" class="Symbol">=</a> <a id="28998" href="/Denot/#4501" class="InductiveConstructor">Bot⊑</a>
<a id="29003" href="/Denot/#28915" class="Function">∈→⊑</a> <a id="29007" class="Symbol">{</a><a id="29008" class="DottedPattern Symbol">.(</a><a id="29010" href="/Denot/#29022" class="DottedPattern Bound">v₂</a> <a id="29013" href="/Denot/#4133" class="DottedPattern InductiveConstructor Operator">↦</a> <a id="29015" href="/Denot/#29027" class="DottedPattern Bound">v₂₁</a><a id="29018" class="DottedPattern Symbol">)</a><a id="29019" class="Symbol">}</a> <a id="29021" class="Symbol">{</a><a id="29022" href="/Denot/#29022" class="Bound">v₂</a> <a id="29025" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="29027" href="/Denot/#29027" class="Bound">v₂₁</a><a id="29030" class="Symbol">}</a> <a id="29032" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="29037" class="Symbol">=</a> <a id="29039" href="/Denot/#5698" class="Function">Refl⊑</a>
<a id="29045" href="/Denot/#28915" class="Function">∈→⊑</a> <a id="29049" class="Symbol">{</a><a id="29050" href="/Denot/#29050" class="Bound">v₁</a><a id="29052" class="Symbol">}</a> <a id="29054" class="Symbol">{</a><a id="29055" href="/Denot/#29055" class="Bound">v₂</a> <a id="29058" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="29060" href="/Denot/#29060" class="Bound">v₂₁</a><a id="29063" class="Symbol">}</a> <a id="29065" class="Symbol">(</a><a id="29066" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="29071" href="/Denot/#29071" class="Bound">x</a><a id="29072" class="Symbol">)</a> <a id="29074" class="Symbol">=</a> <a id="29076" href="/Denot/#4627" class="InductiveConstructor">ConjR1⊑</a> <a id="29084" class="Symbol">(</a><a id="29085" href="/Denot/#28915" class="Function">∈→⊑</a> <a id="29089" href="/Denot/#29071" class="Bound">x</a><a id="29090" class="Symbol">)</a>
<a id="29092" href="/Denot/#28915" class="Function">∈→⊑</a> <a id="29096" class="Symbol">{</a><a id="29097" href="/Denot/#29097" class="Bound">v₁</a><a id="29099" class="Symbol">}</a> <a id="29101" class="Symbol">{</a><a id="29102" href="/Denot/#29102" class="Bound">v₂</a> <a id="29105" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="29107" href="/Denot/#29107" class="Bound">v₂₁</a><a id="29110" class="Symbol">}</a> <a id="29112" class="Symbol">(</a><a id="29113" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="29118" href="/Denot/#29118" class="Bound">y</a><a id="29119" class="Symbol">)</a> <a id="29121" class="Symbol">=</a> <a id="29123" href="/Denot/#4708" class="InductiveConstructor">ConjR2⊑</a> <a id="29131" class="Symbol">(</a><a id="29132" href="/Denot/#28915" class="Function">∈→⊑</a> <a id="29136" href="/Denot/#29118" class="Bound">y</a><a id="29137" class="Symbol">)</a>

<a id="⊆→⊑"></a><a id="29140" href="/Denot/#29140" class="Function">⊆→⊑</a> <a id="29144" class="Symbol">:</a> <a id="29146" class="Symbol">∀{</a><a id="29148" href="/Denot/#29148" class="Bound">v₁</a> <a id="29151" href="/Denot/#29151" class="Bound">v₂</a> <a id="29154" class="Symbol">:</a> <a id="29156" href="/Denot/#4101" class="Datatype">Value</a><a id="29161" class="Symbol">}</a>
    <a id="29167" class="Symbol">→</a> <a id="29169" href="/Denot/#29148" class="Bound">v₁</a> <a id="29172" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="29174" href="/Denot/#29151" class="Bound">v₂</a>
      <a id="29183" class="Comment">-----</a>
    <a id="29193" class="Symbol">→</a> <a id="29195" href="/Denot/#29148" class="Bound">v₁</a> <a id="29198" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="29200" href="/Denot/#29151" class="Bound">v₂</a>
<a id="29203" href="/Denot/#29140" class="Function">⊆→⊑</a> <a id="29207" class="Symbol">{</a><a id="29208" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="29209" class="Symbol">}</a> <a id="29211" class="Symbol">{</a><a id="29212" href="/Denot/#29212" class="Bound">v₂</a><a id="29214" class="Symbol">}</a> <a id="29216" href="/Denot/#29216" class="Bound">s</a> <a id="29218" class="Keyword">with</a> <a id="29223" href="/Denot/#29216" class="Bound">s</a> <a id="29225" class="Symbol">{</a><a id="29226" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="29227" class="Symbol">}</a> <a id="29229" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="29234" class="Symbol">...</a> <a id="29238" class="Symbol">|</a> <a id="29240" href="/Denot/#29240" class="Bound">x</a> <a id="29242" class="Symbol">=</a> <a id="29244" href="/Denot/#4501" class="InductiveConstructor">Bot⊑</a>
<a id="29249" href="/Denot/#29140" class="Function">⊆→⊑</a> <a id="29253" class="Symbol">{</a><a id="29254" href="/Denot/#29254" class="Bound">v₁</a> <a id="29257" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="29259" href="/Denot/#29259" class="Bound">v₁&#39;</a><a id="29262" class="Symbol">}</a> <a id="29264" class="Symbol">{</a><a id="29265" href="/Denot/#29265" class="Bound">v₂</a><a id="29267" class="Symbol">}</a> <a id="29269" href="/Denot/#29269" class="Bound">s</a> <a id="29271" class="Keyword">with</a> <a id="29276" href="/Denot/#29269" class="Bound">s</a> <a id="29278" class="Symbol">{</a><a id="29279" href="/Denot/#29254" class="Bound">v₁</a> <a id="29282" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="29284" href="/Denot/#29259" class="Bound">v₁&#39;</a><a id="29287" class="Symbol">}</a> <a id="29289" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="29294" class="Symbol">...</a> <a id="29298" class="Symbol">|</a> <a id="29300" href="/Denot/#29300" class="Bound">x</a> <a id="29302" class="Symbol">=</a> <a id="29304" href="/Denot/#28915" class="Function">∈→⊑</a> <a id="29308" href="/Denot/#29300" class="Bound">x</a>
<a id="29310" href="/Denot/#29140" class="Function">⊆→⊑</a> <a id="29314" class="Symbol">{</a><a id="29315" href="/Denot/#29315" class="Bound">v₁</a> <a id="29318" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="29320" href="/Denot/#29320" class="Bound">v₁&#39;</a><a id="29323" class="Symbol">}</a> <a id="29325" class="Symbol">{</a><a id="29326" href="/Denot/#29326" class="Bound">v₂</a><a id="29328" class="Symbol">}</a> <a id="29330" href="/Denot/#29330" class="Bound">s</a> <a id="29332" class="Symbol">=</a>
   <a id="29337" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="29344" class="Symbol">(</a><a id="29345" href="/Denot/#29140" class="Function">⊆→⊑</a> <a id="29349" class="Symbol">(λ</a> <a id="29352" class="Symbol">{</a><a id="29353" href="/Denot/#29353" class="Bound">C</a><a id="29354" class="Symbol">}</a> <a id="29356" href="/Denot/#29356" class="Bound">z</a> <a id="29358" class="Symbol">→</a> <a id="29360" href="/Denot/#29330" class="Bound">s</a> <a id="29362" class="Symbol">(</a><a id="29363" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="29368" href="/Denot/#29356" class="Bound">z</a><a id="29369" class="Symbol">)))</a> <a id="29373" class="Symbol">(</a><a id="29374" href="/Denot/#29140" class="Function">⊆→⊑</a> <a id="29378" class="Symbol">(λ</a> <a id="29381" class="Symbol">{</a><a id="29382" href="/Denot/#29382" class="Bound">C</a><a id="29383" class="Symbol">}</a> <a id="29385" href="/Denot/#29385" class="Bound">z</a> <a id="29387" class="Symbol">→</a> <a id="29389" href="/Denot/#29330" class="Bound">s</a> <a id="29391" class="Symbol">(</a><a id="29392" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="29397" href="/Denot/#29385" class="Bound">z</a><a id="29398" class="Symbol">)))</a></pre>

<p>We shall also need some inversion principles for value inclusion.  If
the union of v₁ and v₂ is included in v₃, then of course both v₁ and
v₂ are each included in v₃.</p>

<pre class="Agda"><a id="⊔⊆-inv"></a><a id="29595" href="/Denot/#29595" class="Function">⊔⊆-inv</a> <a id="29602" class="Symbol">:</a> <a id="29604" class="Symbol">∀{</a><a id="29606" href="/Denot/#29606" class="Bound">v₁</a> <a id="29609" href="/Denot/#29609" class="Bound">v₂</a> <a id="29612" href="/Denot/#29612" class="Bound">v₃</a> <a id="29615" class="Symbol">:</a> <a id="29617" href="/Denot/#4101" class="Datatype">Value</a><a id="29622" class="Symbol">}</a>
       <a id="29631" class="Symbol">→</a> <a id="29633" class="Symbol">(</a><a id="29634" href="/Denot/#29606" class="Bound">v₁</a> <a id="29637" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="29639" href="/Denot/#29609" class="Bound">v₂</a><a id="29641" class="Symbol">)</a> <a id="29643" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="29645" href="/Denot/#29612" class="Bound">v₃</a>
         <a id="29657" class="Comment">---------------</a>
       <a id="29680" class="Symbol">→</a> <a id="29682" href="/Denot/#29606" class="Bound">v₁</a> <a id="29685" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="29687" href="/Denot/#29612" class="Bound">v₃</a>  <a id="29691" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a>  <a id="29694" href="/Denot/#29609" class="Bound">v₂</a> <a id="29697" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="29699" href="/Denot/#29612" class="Bound">v₃</a>
<a id="29702" href="/Denot/#29595" class="Function">⊔⊆-inv</a> <a id="29709" href="/Denot/#29709" class="Bound">abc</a> <a id="29713" class="Symbol">=</a> <a id="29715" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="29717" class="Symbol">(λ</a> <a id="29720" class="Symbol">{</a><a id="29721" href="/Denot/#29721" class="Bound">x</a><a id="29722" class="Symbol">}</a> <a id="29724" href="/Denot/#29724" class="Bound">x₁</a> <a id="29727" class="Symbol">→</a> <a id="29729" href="/Denot/#29709" class="Bound">abc</a> <a id="29733" class="Symbol">(</a><a id="29734" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="29739" href="/Denot/#29724" class="Bound">x₁</a><a id="29741" class="Symbol">))</a> <a id="29744" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="29746" class="Symbol">(λ</a> <a id="29749" class="Symbol">{</a><a id="29750" href="/Denot/#29750" class="Bound">x</a><a id="29751" class="Symbol">}</a> <a id="29753" href="/Denot/#29753" class="Bound">x₁</a> <a id="29756" class="Symbol">→</a> <a id="29758" href="/Denot/#29709" class="Bound">abc</a> <a id="29762" class="Symbol">(</a><a id="29763" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="29768" href="/Denot/#29753" class="Bound">x₁</a><a id="29770" class="Symbol">))</a> <a id="29773" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>

<p>In our value representation, the function value v₁ ↦ v₂ is both an
element and also a singleton set. So if v₁ ↦ v₂ is a subset of v₃,
then v₁ ↦ v₂ must be a member of v₃.</p>

<pre class="Agda"><a id="↦⊆→∈"></a><a id="29972" href="/Denot/#29972" class="Function">↦⊆→∈</a> <a id="29977" class="Symbol">:</a> <a id="29979" class="Symbol">∀{</a><a id="29981" href="/Denot/#29981" class="Bound">v₁</a> <a id="29984" href="/Denot/#29984" class="Bound">v₂</a> <a id="29987" href="/Denot/#29987" class="Bound">v₃</a> <a id="29990" class="Symbol">:</a> <a id="29992" href="/Denot/#4101" class="Datatype">Value</a><a id="29997" class="Symbol">}</a>
     <a id="30004" class="Symbol">→</a> <a id="30006" href="/Denot/#29981" class="Bound">v₁</a> <a id="30009" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="30011" href="/Denot/#29984" class="Bound">v₂</a> <a id="30014" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="30016" href="/Denot/#29987" class="Bound">v₃</a>
       <a id="30026" class="Comment">---------</a>
     <a id="30041" class="Symbol">→</a> <a id="30043" href="/Denot/#29981" class="Bound">v₁</a> <a id="30046" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="30048" href="/Denot/#29984" class="Bound">v₂</a> <a id="30051" href="/Denot/#28361" class="Function Operator">∈</a> <a id="30053" href="/Denot/#29987" class="Bound">v₃</a>
<a id="30056" href="/Denot/#29972" class="Function">↦⊆→∈</a><a id="30060" class="Symbol">{</a><a id="30061" href="/Denot/#30061" class="Bound">v₁</a><a id="30063" class="Symbol">}{</a><a id="30065" href="/Denot/#30065" class="Bound">v₂</a><a id="30067" class="Symbol">}{</a><a id="30069" href="/Denot/#30069" class="Bound">v₃</a><a id="30071" class="Symbol">}</a> <a id="30073" href="/Denot/#30073" class="Bound">incl</a> <a id="30078" class="Symbol">=</a> <a id="30080" href="/Denot/#30073" class="Bound">incl</a> <a id="30085" class="Symbol">{</a><a id="30086" href="/Denot/#30061" class="Bound">v₁</a> <a id="30089" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="30091" href="/Denot/#30065" class="Bound">v₂</a><a id="30093" class="Symbol">}</a> <a id="30095" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a></pre>

<h3 id="function-values">Function values</h3>

<p>To identify collections of functions, we define the following two
predicates. We write Fun v₁ if v₁ is a function value, that is, if v₁
≡ v ↦ v’ for some values v and v’. We write Funs v if all the elements
of v are functions.</p>

<pre class="Agda"><a id="30376" class="Keyword">data</a> <a id="Fun"></a><a id="30381" href="/Denot/#30381" class="Datatype">Fun</a> <a id="30385" class="Symbol">:</a> <a id="30387" href="/Denot/#4101" class="Datatype">Value</a> <a id="30393" class="Symbol">→</a> <a id="30395" class="PrimitiveType">Set</a> <a id="30399" class="Keyword">where</a>
  <a id="Fun.fun"></a><a id="30407" href="/Denot/#30407" class="InductiveConstructor">fun</a> <a id="30411" class="Symbol">:</a> <a id="30413" class="Symbol">∀{</a><a id="30415" href="/Denot/#30415" class="Bound">v₁</a> <a id="30418" href="/Denot/#30418" class="Bound">v</a> <a id="30420" href="/Denot/#30420" class="Bound">v&#39;</a><a id="30422" class="Symbol">}</a> <a id="30424" class="Symbol">→</a> <a id="30426" href="/Denot/#30415" class="Bound">v₁</a> <a id="30429" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#83" class="Datatype Operator">≡</a> <a id="30431" class="Symbol">(</a><a id="30432" href="/Denot/#30418" class="Bound">v</a> <a id="30434" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="30436" href="/Denot/#30420" class="Bound">v&#39;</a><a id="30438" class="Symbol">)</a> <a id="30440" class="Symbol">→</a> <a id="30442" href="/Denot/#30381" class="Datatype">Fun</a> <a id="30446" href="/Denot/#30415" class="Bound">v₁</a>

<a id="Funs"></a><a id="30450" href="/Denot/#30450" class="Function">Funs</a> <a id="30455" class="Symbol">:</a> <a id="30457" href="/Denot/#4101" class="Datatype">Value</a> <a id="30463" class="Symbol">→</a> <a id="30465" class="PrimitiveType">Set</a>
<a id="30469" href="/Denot/#30450" class="Function">Funs</a> <a id="30474" href="/Denot/#30474" class="Bound">v</a> <a id="30476" class="Symbol">=</a> <a id="30478" class="Symbol">∀{</a><a id="30480" href="/Denot/#30480" class="Bound">v&#39;</a><a id="30482" class="Symbol">}</a> <a id="30484" class="Symbol">→</a> <a id="30486" href="/Denot/#30480" class="Bound">v&#39;</a> <a id="30489" href="/Denot/#28361" class="Function Operator">∈</a> <a id="30491" href="/Denot/#30474" class="Bound">v</a> <a id="30493" class="Symbol">→</a> <a id="30495" href="/Denot/#30381" class="Datatype">Fun</a> <a id="30499" href="/Denot/#30480" class="Bound">v&#39;</a></pre>

<p>Of course, the value ⊥ is not a function.</p>

<pre class="Agda"><a id="¬Fun⊥"></a><a id="30570" href="/Denot/#30570" class="Function">¬Fun⊥</a> <a id="30576" class="Symbol">:</a> <a id="30578" href="https://agda.github.io/agda-stdlib/Relation.Nullary.html#464" class="Function Operator">¬</a> <a id="30580" class="Symbol">(</a><a id="30581" href="/Denot/#30381" class="Datatype">Fun</a> <a id="30585" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="30586" class="Symbol">)</a>
<a id="30588" href="/Denot/#30570" class="Function">¬Fun⊥</a> <a id="30594" class="Symbol">(</a><a id="30595" href="/Denot/#30407" class="InductiveConstructor">fun</a> <a id="30599" class="Symbol">())</a></pre>

<p>In our values-as-sets representation, our sets always include at least
one element. Thus, if all the elements are functions, there is at
least one that is a function.</p>

<pre class="Agda"><a id="Funs∈"></a><a id="30796" href="/Denot/#30796" class="Function">Funs∈</a> <a id="30802" class="Symbol">:</a> <a id="30804" class="Symbol">∀{</a><a id="30806" href="/Denot/#30806" class="Bound">v₁</a><a id="30808" class="Symbol">}</a>
      <a id="30816" class="Symbol">→</a> <a id="30818" href="/Denot/#30450" class="Function">Funs</a> <a id="30823" href="/Denot/#30806" class="Bound">v₁</a>
      <a id="30832" class="Symbol">→</a> <a id="30834" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">Σ[</a> <a id="30837" href="/Denot/#30837" class="Bound">v</a> <a id="30839" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">∈</a> <a id="30841" href="/Denot/#4101" class="Datatype">Value</a> <a id="30847" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">]</a> <a id="30849" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">Σ[</a> <a id="30852" href="/Denot/#30852" class="Bound">v&#39;</a> <a id="30855" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">∈</a> <a id="30857" href="/Denot/#4101" class="Datatype">Value</a> <a id="30863" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">]</a> <a id="30865" href="/Denot/#30837" class="Bound">v</a> <a id="30867" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="30869" href="/Denot/#30852" class="Bound">v&#39;</a> <a id="30872" href="/Denot/#28361" class="Function Operator">∈</a> <a id="30874" href="/Denot/#30806" class="Bound">v₁</a>
<a id="30877" href="/Denot/#30796" class="Function">Funs∈</a> <a id="30883" class="Symbol">{</a><a id="30884" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="30885" class="Symbol">}</a> <a id="30887" href="/Denot/#30887" class="Bound">f</a> <a id="30889" class="Keyword">with</a> <a id="30894" href="/Denot/#30887" class="Bound">f</a> <a id="30896" class="Symbol">{</a><a id="30897" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="30898" class="Symbol">}</a> <a id="30900" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="30905" class="Symbol">...</a> <a id="30909" class="Symbol">|</a> <a id="30911" href="/Denot/#30407" class="InductiveConstructor">fun</a> <a id="30915" class="Symbol">()</a>
<a id="30918" href="/Denot/#30796" class="Function">Funs∈</a> <a id="30924" class="Symbol">{</a><a id="30925" href="/Denot/#30925" class="Bound">v</a> <a id="30927" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="30929" href="/Denot/#30929" class="Bound">v&#39;</a><a id="30931" class="Symbol">}</a> <a id="30933" href="/Denot/#30933" class="Bound">f</a> <a id="30935" class="Symbol">=</a> <a id="30937" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="30939" href="/Denot/#30925" class="Bound">v</a> <a id="30941" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="30943" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="30945" href="/Denot/#30929" class="Bound">v&#39;</a> <a id="30948" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="30950" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="30955" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="30957" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="30959" href="/Denot/#30796" class="Function">Funs∈</a> <a id="30965" class="Symbol">{</a><a id="30966" href="/Denot/#30966" class="Bound">v₁</a> <a id="30969" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="30971" href="/Denot/#30971" class="Bound">v₂</a><a id="30973" class="Symbol">}</a> <a id="30975" href="/Denot/#30975" class="Bound">f</a>
    <a id="30981" class="Keyword">with</a> <a id="30986" href="/Denot/#30796" class="Function">Funs∈</a> <a id="30992" class="Symbol">{</a><a id="30993" href="/Denot/#30966" class="Bound">v₁</a><a id="30995" class="Symbol">}</a> <a id="30997" class="Symbol">λ</a> <a id="30999" class="Symbol">{</a><a id="31000" href="/Denot/#31000" class="Bound">v&#39;</a><a id="31002" class="Symbol">}</a> <a id="31004" href="/Denot/#31004" class="Bound">z</a> <a id="31006" class="Symbol">→</a> <a id="31008" href="/Denot/#30975" class="Bound">f</a> <a id="31010" class="Symbol">(</a><a id="31011" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="31016" href="/Denot/#31004" class="Bound">z</a><a id="31017" class="Symbol">)</a>
<a id="31019" class="Symbol">...</a> <a id="31023" class="Symbol">|</a> <a id="31025" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="31027" href="/Denot/#31027" class="Bound">v</a> <a id="31029" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="31031" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="31033" href="/Denot/#31033" class="Bound">v&#39;</a> <a id="31036" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="31038" href="/Denot/#31038" class="Bound">m</a> <a id="31040" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="31042" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="31044" class="Symbol">=</a> <a id="31046" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="31048" href="/Denot/#31027" class="Bound">v</a> <a id="31050" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="31052" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="31054" href="/Denot/#31033" class="Bound">v&#39;</a> <a id="31057" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="31059" class="Symbol">(</a><a id="31060" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="31065" href="/Denot/#31038" class="Bound">m</a><a id="31066" class="Symbol">)</a> <a id="31068" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="31070" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>

<h3 id="domains-and-codomains">Domains and codomains</h3>

<p>Returning to our goal, the inversion principle for less-than a
function, we want to show that v₁ ↦ v₁’ ⊑ v₂ implies that v₂ includes
a set of function values such that the join of their domains is less
than v₁ and the join of their codomains is greater than v₁’.</p>

<p>To this end we define the following dom and cod functions.  Given some
value v (that represents a set of entries), dom v returns the join of
their domains and cod v returns the join of their codomains.</p>

<pre class="Agda"><a id="dom"></a><a id="31592" href="/Denot/#31592" class="Function">dom</a> <a id="31596" class="Symbol">:</a> <a id="31598" class="Symbol">(</a><a id="31599" href="/Denot/#31599" class="Bound">v</a> <a id="31601" class="Symbol">:</a> <a id="31603" href="/Denot/#4101" class="Datatype">Value</a><a id="31608" class="Symbol">)</a> <a id="31610" class="Symbol">→</a> <a id="31612" href="/Denot/#4101" class="Datatype">Value</a>
<a id="31618" href="/Denot/#31592" class="Function">dom</a> <a id="31622" href="/Denot/#4121" class="InductiveConstructor">⊥</a>  <a id="31625" class="Symbol">=</a> <a id="31627" href="/Denot/#4121" class="InductiveConstructor">⊥</a>
<a id="31629" href="/Denot/#31592" class="Function">dom</a> <a id="31633" class="Symbol">(</a><a id="31634" href="/Denot/#31634" class="Bound">v</a> <a id="31636" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="31638" href="/Denot/#31638" class="Bound">v&#39;</a><a id="31640" class="Symbol">)</a> <a id="31642" class="Symbol">=</a> <a id="31644" href="/Denot/#31634" class="Bound">v</a>
<a id="31646" href="/Denot/#31592" class="Function">dom</a> <a id="31650" class="Symbol">(</a><a id="31651" href="/Denot/#31651" class="Bound">v</a> <a id="31653" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="31655" href="/Denot/#31655" class="Bound">v&#39;</a><a id="31657" class="Symbol">)</a> <a id="31659" class="Symbol">=</a> <a id="31661" href="/Denot/#31592" class="Function">dom</a> <a id="31665" href="/Denot/#31651" class="Bound">v</a> <a id="31667" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="31669" href="/Denot/#31592" class="Function">dom</a> <a id="31673" href="/Denot/#31655" class="Bound">v&#39;</a>

<a id="cod"></a><a id="31677" href="/Denot/#31677" class="Function">cod</a> <a id="31681" class="Symbol">:</a> <a id="31683" class="Symbol">(</a><a id="31684" href="/Denot/#31684" class="Bound">v</a> <a id="31686" class="Symbol">:</a> <a id="31688" href="/Denot/#4101" class="Datatype">Value</a><a id="31693" class="Symbol">)</a> <a id="31695" class="Symbol">→</a> <a id="31697" href="/Denot/#4101" class="Datatype">Value</a>
<a id="31703" href="/Denot/#31677" class="Function">cod</a> <a id="31707" href="/Denot/#4121" class="InductiveConstructor">⊥</a>  <a id="31710" class="Symbol">=</a> <a id="31712" href="/Denot/#4121" class="InductiveConstructor">⊥</a>
<a id="31714" href="/Denot/#31677" class="Function">cod</a> <a id="31718" class="Symbol">(</a><a id="31719" href="/Denot/#31719" class="Bound">v</a> <a id="31721" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="31723" href="/Denot/#31723" class="Bound">v&#39;</a><a id="31725" class="Symbol">)</a> <a id="31727" class="Symbol">=</a> <a id="31729" href="/Denot/#31723" class="Bound">v&#39;</a>
<a id="31732" href="/Denot/#31677" class="Function">cod</a> <a id="31736" class="Symbol">(</a><a id="31737" href="/Denot/#31737" class="Bound">v</a> <a id="31739" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="31741" href="/Denot/#31741" class="Bound">v&#39;</a><a id="31743" class="Symbol">)</a> <a id="31745" class="Symbol">=</a> <a id="31747" href="/Denot/#31677" class="Function">cod</a> <a id="31751" href="/Denot/#31737" class="Bound">v</a> <a id="31753" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="31755" href="/Denot/#31677" class="Function">cod</a> <a id="31759" href="/Denot/#31741" class="Bound">v&#39;</a></pre>

<p>We need just one property each for dom and cod.  Given a collection of
functions represented by value v, and an entry v₁ ↦ v₂ in v, we know
that v₁ is included in the domain of v.</p>

<pre class="Agda"><a id="↦∈→⊆dom"></a><a id="31968" href="/Denot/#31968" class="Function">↦∈→⊆dom</a> <a id="31976" class="Symbol">:</a> <a id="31978" class="Symbol">∀{</a><a id="31980" href="/Denot/#31980" class="Bound">v</a> <a id="31982" href="/Denot/#31982" class="Bound">v₁</a> <a id="31985" href="/Denot/#31985" class="Bound">v₂</a> <a id="31988" class="Symbol">:</a> <a id="31990" href="/Denot/#4101" class="Datatype">Value</a><a id="31995" class="Symbol">}</a>
          <a id="32007" class="Symbol">→</a> <a id="32009" href="/Denot/#30450" class="Function">Funs</a> <a id="32014" href="/Denot/#31980" class="Bound">v</a>  <a id="32017" class="Symbol">→</a>  <a id="32020" class="Symbol">(</a><a id="32021" href="/Denot/#31982" class="Bound">v₁</a> <a id="32024" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="32026" href="/Denot/#31985" class="Bound">v₂</a><a id="32028" class="Symbol">)</a> <a id="32030" href="/Denot/#28361" class="Function Operator">∈</a> <a id="32032" href="/Denot/#31980" class="Bound">v</a>
            <a id="32046" class="Comment">----------------------</a>
          <a id="32079" class="Symbol">→</a> <a id="32081" href="/Denot/#31982" class="Bound">v₁</a> <a id="32084" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="32086" href="/Denot/#31592" class="Function">dom</a> <a id="32090" href="/Denot/#31980" class="Bound">v</a>
<a id="32092" href="/Denot/#31968" class="Function">↦∈→⊆dom</a> <a id="32100" class="Symbol">{</a><a id="32101" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="32102" class="Symbol">}</a> <a id="32104" href="/Denot/#32104" class="Bound">fg</a> <a id="32107" class="Symbol">()</a>
<a id="32110" href="/Denot/#31968" class="Function">↦∈→⊆dom</a> <a id="32118" class="Symbol">{</a><a id="32119" href="/Denot/#32119" class="Bound">v</a> <a id="32121" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="32123" href="/Denot/#32123" class="Bound">v&#39;</a><a id="32125" class="Symbol">}</a> <a id="32127" href="/Denot/#32127" class="Bound">fg</a> <a id="32130" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="32135" class="Symbol">=</a> <a id="32137" class="Symbol">λ</a> <a id="32139" href="/Denot/#32139" class="Bound">z</a> <a id="32141" class="Symbol">→</a> <a id="32143" href="/Denot/#32139" class="Bound">z</a>
<a id="32145" href="/Denot/#31968" class="Function">↦∈→⊆dom</a> <a id="32153" class="Symbol">{</a><a id="32154" href="/Denot/#32154" class="Bound">v</a> <a id="32156" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="32158" href="/Denot/#32158" class="Bound">v&#39;</a><a id="32160" class="Symbol">}</a> <a id="32162" href="/Denot/#32162" class="Bound">fg</a> <a id="32165" class="Symbol">(</a><a id="32166" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="32171" href="/Denot/#32171" class="Bound">x</a><a id="32172" class="Symbol">)</a> <a id="32174" class="Symbol">=</a>
  <a id="32178" class="Keyword">let</a> <a id="32182" href="/Denot/#32182" class="Bound">ih</a> <a id="32185" class="Symbol">=</a> <a id="32187" href="/Denot/#31968" class="Function">↦∈→⊆dom</a> <a id="32195" class="Symbol">{</a><a id="32196" href="/Denot/#32154" class="Bound">v</a><a id="32197" class="Symbol">}</a> <a id="32199" class="Symbol">(λ</a> <a id="32202" class="Symbol">{</a><a id="32203" href="/Denot/#32203" class="Bound">v&#39;</a><a id="32205" class="Symbol">}</a> <a id="32207" href="/Denot/#32207" class="Bound">z</a> <a id="32209" class="Symbol">→</a> <a id="32211" href="/Denot/#32162" class="Bound">fg</a> <a id="32214" class="Symbol">(</a><a id="32215" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="32220" href="/Denot/#32207" class="Bound">z</a><a id="32221" class="Symbol">))</a> <a id="32224" href="/Denot/#32171" class="Bound">x</a> <a id="32226" class="Keyword">in</a>
  <a id="32231" class="Symbol">λ</a> <a id="32233" href="/Denot/#32233" class="Bound">x₁</a> <a id="32236" class="Symbol">→</a> <a id="32238" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="32243" class="Symbol">(</a><a id="32244" href="/Denot/#32182" class="Bound">ih</a> <a id="32247" href="/Denot/#32233" class="Bound">x₁</a><a id="32249" class="Symbol">)</a>
<a id="32251" href="/Denot/#31968" class="Function">↦∈→⊆dom</a> <a id="32259" class="Symbol">{</a><a id="32260" href="/Denot/#32260" class="Bound">v</a> <a id="32262" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="32264" href="/Denot/#32264" class="Bound">v&#39;</a><a id="32266" class="Symbol">}</a> <a id="32268" href="/Denot/#32268" class="Bound">fg</a> <a id="32271" class="Symbol">(</a><a id="32272" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="32277" href="/Denot/#32277" class="Bound">y</a><a id="32278" class="Symbol">)</a> <a id="32280" class="Symbol">=</a>
  <a id="32284" class="Keyword">let</a> <a id="32288" href="/Denot/#32288" class="Bound">ih</a> <a id="32291" class="Symbol">=</a> <a id="32293" href="/Denot/#31968" class="Function">↦∈→⊆dom</a> <a id="32301" class="Symbol">{</a><a id="32302" href="/Denot/#32264" class="Bound">v&#39;</a><a id="32304" class="Symbol">}</a> <a id="32306" class="Symbol">(λ</a> <a id="32309" class="Symbol">{</a><a id="32310" href="/Denot/#32310" class="Bound">v&#39;</a><a id="32312" class="Symbol">}</a> <a id="32314" href="/Denot/#32314" class="Bound">z</a> <a id="32316" class="Symbol">→</a> <a id="32318" href="/Denot/#32268" class="Bound">fg</a> <a id="32321" class="Symbol">(</a><a id="32322" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="32327" href="/Denot/#32314" class="Bound">z</a><a id="32328" class="Symbol">))</a> <a id="32331" href="/Denot/#32277" class="Bound">y</a> <a id="32333" class="Keyword">in</a>
  <a id="32338" class="Symbol">λ</a> <a id="32340" href="/Denot/#32340" class="Bound">x₁</a> <a id="32343" class="Symbol">→</a> <a id="32345" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="32350" class="Symbol">(</a><a id="32351" href="/Denot/#32288" class="Bound">ih</a> <a id="32354" href="/Denot/#32340" class="Bound">x₁</a><a id="32356" class="Symbol">)</a></pre>

<p>Regarding cod, suppose we have a collection of functions represented
by v, but all of them are just copies of v₁ ↦ v₂.  Then the cod v is
included in v₂.</p>

<pre class="Agda"><a id="⊆↦→cod⊆"></a><a id="32538" href="/Denot/#32538" class="Function">⊆↦→cod⊆</a> <a id="32546" class="Symbol">:</a> <a id="32548" class="Symbol">∀{</a><a id="32550" href="/Denot/#32550" class="Bound">v</a> <a id="32552" href="/Denot/#32552" class="Bound">v₁</a> <a id="32555" href="/Denot/#32555" class="Bound">v₂</a> <a id="32558" class="Symbol">:</a> <a id="32560" href="/Denot/#4101" class="Datatype">Value</a><a id="32565" class="Symbol">}</a>
      <a id="32573" class="Symbol">→</a> <a id="32575" href="/Denot/#32550" class="Bound">v</a> <a id="32577" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="32579" href="/Denot/#32552" class="Bound">v₁</a> <a id="32582" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="32584" href="/Denot/#32555" class="Bound">v₂</a>
        <a id="32595" class="Comment">---------</a>
      <a id="32611" class="Symbol">→</a> <a id="32613" href="/Denot/#31677" class="Function">cod</a> <a id="32617" href="/Denot/#32550" class="Bound">v</a> <a id="32619" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="32621" href="/Denot/#32555" class="Bound">v₂</a>
<a id="32624" href="/Denot/#32538" class="Function">⊆↦→cod⊆</a> <a id="32632" class="Symbol">{</a><a id="32633" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="32634" class="Symbol">}</a> <a id="32636" href="/Denot/#32636" class="Bound">s</a> <a id="32638" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="32643" class="Keyword">with</a> <a id="32648" href="/Denot/#32636" class="Bound">s</a> <a id="32650" class="Symbol">{</a><a id="32651" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="32652" class="Symbol">}</a> <a id="32654" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="32659" class="Symbol">...</a> <a id="32663" class="Symbol">|</a> <a id="32665" class="Symbol">()</a>
<a id="32668" href="/Denot/#32538" class="Function">⊆↦→cod⊆</a> <a id="32676" class="Symbol">{</a><a id="32677" href="/Denot/#32677" class="Bound">C</a> <a id="32679" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="32681" href="/Denot/#32681" class="Bound">C&#39;</a><a id="32683" class="Symbol">}</a> <a id="32685" href="/Denot/#32685" class="Bound">s</a> <a id="32687" href="/Denot/#32687" class="Bound">m</a> <a id="32689" class="Keyword">with</a> <a id="32694" href="/Denot/#32685" class="Bound">s</a> <a id="32696" class="Symbol">{</a><a id="32697" href="/Denot/#32677" class="Bound">C</a> <a id="32699" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="32701" href="/Denot/#32681" class="Bound">C&#39;</a><a id="32703" class="Symbol">}</a> <a id="32705" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="32710" class="Symbol">...</a> <a id="32714" class="Symbol">|</a> <a id="32716" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="32721" class="Symbol">=</a> <a id="32723" class="Bound">m</a>
<a id="32725" href="/Denot/#32538" class="Function">⊆↦→cod⊆</a> <a id="32733" class="Symbol">{</a><a id="32734" href="/Denot/#32734" class="Bound">v</a> <a id="32736" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="32738" href="/Denot/#32738" class="Bound">v₁</a><a id="32740" class="Symbol">}</a> <a id="32742" href="/Denot/#32742" class="Bound">s</a> <a id="32744" class="Symbol">(</a><a id="32745" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="32750" href="/Denot/#32750" class="Bound">x</a><a id="32751" class="Symbol">)</a> <a id="32753" class="Symbol">=</a> <a id="32755" href="/Denot/#32538" class="Function">⊆↦→cod⊆</a> <a id="32763" class="Symbol">(λ</a> <a id="32766" class="Symbol">{</a><a id="32767" href="/Denot/#32767" class="Bound">C</a><a id="32768" class="Symbol">}</a> <a id="32770" href="/Denot/#32770" class="Bound">z</a> <a id="32772" class="Symbol">→</a> <a id="32774" href="/Denot/#32742" class="Bound">s</a> <a id="32776" class="Symbol">(</a><a id="32777" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="32782" href="/Denot/#32770" class="Bound">z</a><a id="32783" class="Symbol">))</a> <a id="32786" href="/Denot/#32750" class="Bound">x</a>
<a id="32788" href="/Denot/#32538" class="Function">⊆↦→cod⊆</a> <a id="32796" class="Symbol">{</a><a id="32797" href="/Denot/#32797" class="Bound">v</a> <a id="32799" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="32801" href="/Denot/#32801" class="Bound">v₁</a><a id="32803" class="Symbol">}</a> <a id="32805" href="/Denot/#32805" class="Bound">s</a> <a id="32807" class="Symbol">(</a><a id="32808" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="32813" href="/Denot/#32813" class="Bound">y</a><a id="32814" class="Symbol">)</a> <a id="32816" class="Symbol">=</a> <a id="32818" href="/Denot/#32538" class="Function">⊆↦→cod⊆</a> <a id="32826" class="Symbol">(λ</a> <a id="32829" class="Symbol">{</a><a id="32830" href="/Denot/#32830" class="Bound">C</a><a id="32831" class="Symbol">}</a> <a id="32833" href="/Denot/#32833" class="Bound">z</a> <a id="32835" class="Symbol">→</a> <a id="32837" href="/Denot/#32805" class="Bound">s</a> <a id="32839" class="Symbol">(</a><a id="32840" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="32845" href="/Denot/#32833" class="Bound">z</a><a id="32846" class="Symbol">))</a> <a id="32849" href="/Denot/#32813" class="Bound">y</a></pre>

<p>With the dom and cod functions in hand, we can make precise the
conclusion of the inversion principle for functions, which we package
into the following predicate named factor. We say that v₁ ↦ v₁’
<em>factors</em> v₂ into v₂’ if v₂’ is a included in v₂, if v₂’ contains only
functions, its domain is less than v₁, and its codomain is greater
than v₁’.</p>

<pre class="Agda"><a id="factor"></a><a id="33223" href="/Denot/#33223" class="Function">factor</a> <a id="33230" class="Symbol">:</a> <a id="33232" class="Symbol">(</a><a id="33233" href="/Denot/#33233" class="Bound">v₂</a> <a id="33236" class="Symbol">:</a> <a id="33238" href="/Denot/#4101" class="Datatype">Value</a><a id="33243" class="Symbol">)</a> <a id="33245" class="Symbol">→</a> <a id="33247" class="Symbol">(</a><a id="33248" href="/Denot/#33248" class="Bound">v₂&#39;</a> <a id="33252" class="Symbol">:</a> <a id="33254" href="/Denot/#4101" class="Datatype">Value</a><a id="33259" class="Symbol">)</a> <a id="33261" class="Symbol">→</a> <a id="33263" class="Symbol">(</a><a id="33264" href="/Denot/#33264" class="Bound">v₁</a> <a id="33267" class="Symbol">:</a> <a id="33269" href="/Denot/#4101" class="Datatype">Value</a><a id="33274" class="Symbol">)</a> <a id="33276" class="Symbol">→</a> <a id="33278" class="Symbol">(</a><a id="33279" href="/Denot/#33279" class="Bound">v₁&#39;</a> <a id="33283" class="Symbol">:</a> <a id="33285" href="/Denot/#4101" class="Datatype">Value</a><a id="33290" class="Symbol">)</a> <a id="33292" class="Symbol">→</a> <a id="33294" class="PrimitiveType">Set</a>
<a id="33298" href="/Denot/#33223" class="Function">factor</a> <a id="33305" href="/Denot/#33305" class="Bound">v₂</a> <a id="33308" href="/Denot/#33308" class="Bound">v₂&#39;</a> <a id="33312" href="/Denot/#33312" class="Bound">v₁</a> <a id="33315" href="/Denot/#33315" class="Bound">v₁&#39;</a> <a id="33319" class="Symbol">=</a> <a id="33321" href="/Denot/#30450" class="Function">Funs</a> <a id="33326" href="/Denot/#33308" class="Bound">v₂&#39;</a> <a id="33330" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="33332" href="/Denot/#33308" class="Bound">v₂&#39;</a> <a id="33336" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="33338" href="/Denot/#33305" class="Bound">v₂</a> <a id="33341" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="33343" href="/Denot/#31592" class="Function">dom</a> <a id="33347" href="/Denot/#33308" class="Bound">v₂&#39;</a> <a id="33351" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="33353" href="/Denot/#33312" class="Bound">v₁</a> <a id="33356" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="33358" href="/Denot/#33315" class="Bound">v₁&#39;</a> <a id="33362" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="33364" href="/Denot/#31677" class="Function">cod</a> <a id="33368" href="/Denot/#33308" class="Bound">v₂&#39;</a></pre>

<p>We prove the inversion principle for functions by induction on the
derivation of the less-than relation. To make the induction hypothesis
stronger, we broaden the premise to v₁ ⊑ v₂ (instead of v₁ ↦ v₁’ ⊑
v₂), and strengthen the conclusion to say that for <em>every</em> function
value w₁ ↦ w₁’ ∈ v₁, we have that w₁ ↦ w₁’ factors v₂ into v₂’.</p>

<h3 id="inversion-of-less-than-for-functions-the-case-for-trans">Inversion of less-than for functions, the case for Trans⊑</h3>

<p>The crux of the proof is the case for Trans⊑.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>v₁ ⊑ u   u ⊑ v₂
--------------- (Trans⊑)
    v₁ ⊑ v₂
</code></pre></div></div>

<p>By the induction hypothesis for v₁ ⊑ u, we know
that w₁ ↦ w₁’ factors u into u’, for some value u’,
so we have Funs u’ and u’ ⊆ u.
By the induction hypothesis for u ⊑ v₂, we know
that for any u₁ ↦ u₂ ∈ u, u₁ ↦ u₂ factors v₂ into v₂’.
With these facts in hand, we proceed by induction on u’
to prove that (dom u’) ↦ (cod u’) factors v₂ into v₂’.
We discuss each case of the proof in the text below.</p>

<pre class="Agda"><a id="sub-inv-trans"></a><a id="34310" href="/Denot/#34310" class="Function">sub-inv-trans</a> <a id="34324" class="Symbol">:</a> <a id="34326" class="Symbol">∀{</a><a id="34328" href="/Denot/#34328" class="Bound">u&#39;</a> <a id="34331" href="/Denot/#34331" class="Bound">v₂</a> <a id="34334" href="/Denot/#34334" class="Bound">u</a> <a id="34336" class="Symbol">:</a> <a id="34338" href="/Denot/#4101" class="Datatype">Value</a><a id="34343" class="Symbol">}</a>
    <a id="34349" class="Symbol">→</a> <a id="34351" href="/Denot/#30450" class="Function">Funs</a> <a id="34356" href="/Denot/#34328" class="Bound">u&#39;</a>  <a id="34360" class="Symbol">→</a>  <a id="34363" href="/Denot/#34328" class="Bound">u&#39;</a> <a id="34366" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="34368" href="/Denot/#34334" class="Bound">u</a>
    <a id="34374" class="Symbol">→</a> <a id="34376" class="Symbol">(∀{</a><a id="34379" href="/Denot/#34379" class="Bound">u₁</a> <a id="34382" href="/Denot/#34382" class="Bound">u₂</a><a id="34384" class="Symbol">}</a> <a id="34386" class="Symbol">→</a> <a id="34388" href="/Denot/#34379" class="Bound">u₁</a> <a id="34391" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="34393" href="/Denot/#34382" class="Bound">u₂</a> <a id="34396" href="/Denot/#28361" class="Function Operator">∈</a> <a id="34398" href="/Denot/#34334" class="Bound">u</a> <a id="34400" class="Symbol">→</a> <a id="34402" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">Σ[</a> <a id="34405" href="/Denot/#34405" class="Bound">v₂&#39;</a> <a id="34409" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">∈</a> <a id="34411" href="/Denot/#4101" class="Datatype">Value</a> <a id="34417" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">]</a> <a id="34419" href="/Denot/#33223" class="Function">factor</a> <a id="34426" href="/Denot/#34331" class="Bound">v₂</a> <a id="34429" href="/Denot/#34405" class="Bound">v₂&#39;</a> <a id="34433" href="/Denot/#34379" class="Bound">u₁</a> <a id="34436" href="/Denot/#34382" class="Bound">u₂</a><a id="34438" class="Symbol">)</a>
      <a id="34446" class="Comment">---------------------------------------------------------------</a>
    <a id="34514" class="Symbol">→</a> <a id="34516" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">Σ[</a> <a id="34519" href="/Denot/#34519" class="Bound">v₂&#39;</a> <a id="34523" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">∈</a> <a id="34525" href="/Denot/#4101" class="Datatype">Value</a> <a id="34531" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">]</a> <a id="34533" href="/Denot/#33223" class="Function">factor</a> <a id="34540" href="/Denot/#34331" class="Bound">v₂</a> <a id="34543" href="/Denot/#34519" class="Bound">v₂&#39;</a> <a id="34547" class="Symbol">(</a><a id="34548" href="/Denot/#31592" class="Function">dom</a> <a id="34552" href="/Denot/#34328" class="Bound">u&#39;</a><a id="34554" class="Symbol">)</a> <a id="34556" class="Symbol">(</a><a id="34557" href="/Denot/#31677" class="Function">cod</a> <a id="34561" href="/Denot/#34328" class="Bound">u&#39;</a><a id="34563" class="Symbol">)</a>
<a id="34565" href="/Denot/#34310" class="Function">sub-inv-trans</a> <a id="34579" class="Symbol">{</a><a id="34580" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="34581" class="Symbol">}</a> <a id="34583" class="Symbol">{</a><a id="34584" href="/Denot/#34584" class="Bound">v₂</a><a id="34586" class="Symbol">}</a> <a id="34588" class="Symbol">{</a><a id="34589" href="/Denot/#34589" class="Bound">u</a><a id="34590" class="Symbol">}</a> <a id="34592" href="/Denot/#34592" class="Bound">fu&#39;</a> <a id="34596" href="/Denot/#34596" class="Bound">u&#39;⊆u</a> <a id="34601" href="/Denot/#34601" class="Bound">IH</a> <a id="34604" class="Symbol">=</a>
   <a id="34609" href="https://agda.github.io/agda-stdlib/Data.Empty.html#360" class="Function">⊥-elim</a> <a id="34616" class="Symbol">(</a><a id="34617" href="https://agda.github.io/agda-stdlib/Relation.Nullary.Negation.html#560" class="Function">contradiction</a> <a id="34631" class="Symbol">(</a><a id="34632" href="/Denot/#34592" class="Bound">fu&#39;</a><a id="34635" class="Symbol">{</a><a id="34636" class="Argument">v&#39;</a> <a id="34639" class="Symbol">=</a> <a id="34641" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="34642" class="Symbol">}</a> <a id="34644" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a><a id="34648" class="Symbol">)</a> <a id="34650" href="/Denot/#30570" class="Function">¬Fun⊥</a><a id="34655" class="Symbol">)</a>
<a id="34657" href="/Denot/#34310" class="Function">sub-inv-trans</a> <a id="34671" class="Symbol">{</a><a id="34672" href="/Denot/#34672" class="Bound">u₁&#39;</a> <a id="34676" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="34678" href="/Denot/#34678" class="Bound">u₂&#39;</a><a id="34681" class="Symbol">}</a> <a id="34683" class="Symbol">{</a><a id="34684" href="/Denot/#34684" class="Bound">v₂</a><a id="34686" class="Symbol">}</a> <a id="34688" class="Symbol">{</a><a id="34689" href="/Denot/#34689" class="Bound">u</a><a id="34690" class="Symbol">}</a> <a id="34692" href="/Denot/#34692" class="Bound">fg</a> <a id="34695" href="/Denot/#34695" class="Bound">u&#39;⊆u</a> <a id="34700" href="/Denot/#34700" class="Bound">IH</a> <a id="34703" class="Symbol">=</a> <a id="34705" href="/Denot/#34700" class="Bound">IH</a> <a id="34708" class="Symbol">(</a><a id="34709" href="/Denot/#29972" class="Function">↦⊆→∈</a> <a id="34714" href="/Denot/#34695" class="Bound">u&#39;⊆u</a><a id="34718" class="Symbol">)</a>
<a id="34720" href="/Denot/#34310" class="Function">sub-inv-trans</a> <a id="34734" class="Symbol">{</a><a id="34735" href="/Denot/#34735" class="Bound">u₁&#39;</a> <a id="34739" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="34741" href="/Denot/#34741" class="Bound">u₂&#39;</a><a id="34744" class="Symbol">}</a> <a id="34746" class="Symbol">{</a><a id="34747" href="/Denot/#34747" class="Bound">v₂</a><a id="34749" class="Symbol">}</a> <a id="34751" class="Symbol">{</a><a id="34752" href="/Denot/#34752" class="Bound">u</a><a id="34753" class="Symbol">}</a> <a id="34755" href="/Denot/#34755" class="Bound">fg</a> <a id="34758" href="/Denot/#34758" class="Bound">u&#39;⊆u</a> <a id="34763" href="/Denot/#34763" class="Bound">IH</a>
    <a id="34770" class="Keyword">with</a> <a id="34775" href="/Denot/#29595" class="Function">⊔⊆-inv</a> <a id="34782" href="/Denot/#34758" class="Bound">u&#39;⊆u</a>
<a id="34787" class="Symbol">...</a> <a id="34791" class="Symbol">|</a> <a id="34793" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="34795" href="/Denot/#34795" class="Bound">u₁&#39;⊆u</a> <a id="34801" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="34803" href="/Denot/#34803" class="Bound">u₂&#39;⊆u</a> <a id="34809" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
    <a id="34815" class="Keyword">with</a> <a id="34820" href="/Denot/#34310" class="Function">sub-inv-trans</a> <a id="34834" class="Symbol">{</a><a id="34835" class="Bound">u₁&#39;</a><a id="34838" class="Symbol">}</a> <a id="34840" class="Symbol">{</a><a id="34841" class="Bound">v₂</a><a id="34843" class="Symbol">}</a> <a id="34845" class="Symbol">{</a><a id="34846" class="Bound">u</a><a id="34847" class="Symbol">}</a> <a id="34849" class="Symbol">(λ</a> <a id="34852" class="Symbol">{</a><a id="34853" href="/Denot/#34853" class="Bound">v&#39;</a><a id="34855" class="Symbol">}</a> <a id="34857" href="/Denot/#34857" class="Bound">z</a> <a id="34859" class="Symbol">→</a> <a id="34861" class="Bound">fg</a> <a id="34864" class="Symbol">(</a><a id="34865" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="34870" href="/Denot/#34857" class="Bound">z</a><a id="34871" class="Symbol">))</a> <a id="34874" href="/Denot/#34795" class="Bound">u₁&#39;⊆u</a> <a id="34880" class="Bound">IH</a>
       <a id="34890" class="Symbol">|</a> <a id="34892" href="/Denot/#34310" class="Function">sub-inv-trans</a> <a id="34906" class="Symbol">{</a><a id="34907" class="Bound">u₂&#39;</a><a id="34910" class="Symbol">}</a> <a id="34912" class="Symbol">{</a><a id="34913" class="Bound">v₂</a><a id="34915" class="Symbol">}</a> <a id="34917" class="Symbol">{</a><a id="34918" class="Bound">u</a><a id="34919" class="Symbol">}</a> <a id="34921" class="Symbol">(λ</a> <a id="34924" class="Symbol">{</a><a id="34925" href="/Denot/#34925" class="Bound">v&#39;</a><a id="34927" class="Symbol">}</a> <a id="34929" href="/Denot/#34929" class="Bound">z</a> <a id="34931" class="Symbol">→</a> <a id="34933" class="Bound">fg</a> <a id="34936" class="Symbol">(</a><a id="34937" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="34942" href="/Denot/#34929" class="Bound">z</a><a id="34943" class="Symbol">))</a> <a id="34946" href="/Denot/#34803" class="Bound">u₂&#39;⊆u</a> <a id="34952" class="Bound">IH</a>
<a id="34955" class="Symbol">...</a> <a id="34959" class="Symbol">|</a> <a id="34961" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="34963" href="/Denot/#34963" class="Bound">v₂₁&#39;</a> <a id="34968" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="34970" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="34972" href="/Denot/#34972" class="Bound">fu21&#39;</a> <a id="34978" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="34980" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="34982" href="/Denot/#34982" class="Bound">v₂₁&#39;⊆v₂</a> <a id="34990" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="34992" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="34994" href="/Denot/#34994" class="Bound">dv₂₁&#39;⊑du₁&#39;</a> <a id="35005" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="35007" href="/Denot/#35007" class="Bound">cu₁&#39;⊑cv₂₁&#39;</a> <a id="35018" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35020" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35022" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35024" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
    <a id="35030" class="Symbol">|</a> <a id="35032" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="35034" href="/Denot/#35034" class="Bound">v₂₂&#39;</a> <a id="35039" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="35041" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="35043" href="/Denot/#35043" class="Bound">fu22&#39;</a> <a id="35049" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="35051" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="35053" href="/Denot/#35053" class="Bound">v₂₂&#39;⊆v₂</a> <a id="35061" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="35063" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="35065" href="/Denot/#35065" class="Bound">dv₂₂&#39;⊑du₂&#39;</a> <a id="35076" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="35078" href="/Denot/#35078" class="Bound">cu₁&#39;⊑cv₂₂&#39;</a> <a id="35089" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35091" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35093" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35095" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35097" class="Symbol">=</a>
      <a id="35105" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="35107" class="Symbol">(</a><a id="35108" href="/Denot/#34963" class="Bound">v₂₁&#39;</a> <a id="35113" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="35115" href="/Denot/#35034" class="Bound">v₂₂&#39;</a><a id="35119" class="Symbol">)</a> <a id="35121" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="35123" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="35125" href="/Denot/#35231" class="Function">fv₂&#39;</a> <a id="35130" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="35132" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="35134" href="/Denot/#35372" class="Function">v₂&#39;⊆v₂</a> <a id="35141" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a>
      <a id="35149" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="35151" href="/Denot/#5967" class="Function">⊔⊑⊔</a> <a id="35155" href="/Denot/#34994" class="Bound">dv₂₁&#39;⊑du₁&#39;</a> <a id="35166" href="/Denot/#35065" class="Bound">dv₂₂&#39;⊑du₂&#39;</a> <a id="35177" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a>
        <a id="35187" href="/Denot/#5967" class="Function">⊔⊑⊔</a> <a id="35191" href="/Denot/#35007" class="Bound">cu₁&#39;⊑cv₂₁&#39;</a> <a id="35202" href="/Denot/#35078" class="Bound">cu₁&#39;⊑cv₂₂&#39;</a> <a id="35213" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35215" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35217" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="35219" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
    <a id="35225" class="Keyword">where</a> <a id="35231" href="/Denot/#35231" class="Function">fv₂&#39;</a> <a id="35236" class="Symbol">:</a> <a id="35238" class="Symbol">{</a><a id="35239" href="/Denot/#35239" class="Bound">v&#39;</a> <a id="35242" class="Symbol">:</a> <a id="35244" href="/Denot/#4101" class="Datatype">Value</a><a id="35249" class="Symbol">}</a> <a id="35251" class="Symbol">→</a> <a id="35253" href="/Denot/#35239" class="Bound">v&#39;</a> <a id="35256" href="/Denot/#28361" class="Function Operator">∈</a> <a id="35258" href="/Denot/#34963" class="Bound">v₂₁&#39;</a> <a id="35263" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">⊎</a> <a id="35265" href="/Denot/#35239" class="Bound">v&#39;</a> <a id="35268" href="/Denot/#28361" class="Function Operator">∈</a> <a id="35270" href="/Denot/#35034" class="Bound">v₂₂&#39;</a> <a id="35275" class="Symbol">→</a> <a id="35277" href="/Denot/#30381" class="Datatype">Fun</a> <a id="35281" href="/Denot/#35239" class="Bound">v&#39;</a>
          <a id="35294" href="/Denot/#35231" class="Function">fv₂&#39;</a> <a id="35299" class="Symbol">{</a><a id="35300" href="/Denot/#35300" class="Bound">v&#39;</a><a id="35302" class="Symbol">}</a> <a id="35304" class="Symbol">(</a><a id="35305" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="35310" href="/Denot/#35310" class="Bound">x</a><a id="35311" class="Symbol">)</a> <a id="35313" class="Symbol">=</a> <a id="35315" href="/Denot/#34972" class="Bound">fu21&#39;</a> <a id="35321" href="/Denot/#35310" class="Bound">x</a>
          <a id="35333" href="/Denot/#35231" class="Function">fv₂&#39;</a> <a id="35338" class="Symbol">{</a><a id="35339" href="/Denot/#35339" class="Bound">v&#39;</a><a id="35341" class="Symbol">}</a> <a id="35343" class="Symbol">(</a><a id="35344" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="35349" href="/Denot/#35349" class="Bound">y</a><a id="35350" class="Symbol">)</a> <a id="35352" class="Symbol">=</a> <a id="35354" href="/Denot/#35043" class="Bound">fu22&#39;</a> <a id="35360" href="/Denot/#35349" class="Bound">y</a>
          <a id="35372" href="/Denot/#35372" class="Function">v₂&#39;⊆v₂</a> <a id="35379" class="Symbol">:</a> <a id="35381" class="Symbol">{</a><a id="35382" href="/Denot/#35382" class="Bound">C</a> <a id="35384" class="Symbol">:</a> <a id="35386" href="/Denot/#4101" class="Datatype">Value</a><a id="35391" class="Symbol">}</a> <a id="35393" class="Symbol">→</a> <a id="35395" href="/Denot/#35382" class="Bound">C</a> <a id="35397" href="/Denot/#28361" class="Function Operator">∈</a> <a id="35399" href="/Denot/#34963" class="Bound">v₂₁&#39;</a> <a id="35404" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#419" class="Datatype Operator">⊎</a> <a id="35406" href="/Denot/#35382" class="Bound">C</a> <a id="35408" href="/Denot/#28361" class="Function Operator">∈</a> <a id="35410" href="/Denot/#35034" class="Bound">v₂₂&#39;</a> <a id="35415" class="Symbol">→</a> <a id="35417" href="/Denot/#35382" class="Bound">C</a> <a id="35419" href="/Denot/#28361" class="Function Operator">∈</a> <a id="35421" class="Bound">v₂</a>
          <a id="35434" href="/Denot/#35372" class="Function">v₂&#39;⊆v₂</a> <a id="35441" class="Symbol">{</a><a id="35442" href="/Denot/#35442" class="Bound">C</a><a id="35443" class="Symbol">}</a> <a id="35445" class="Symbol">(</a><a id="35446" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="35451" href="/Denot/#35451" class="Bound">x</a><a id="35452" class="Symbol">)</a> <a id="35454" class="Symbol">=</a> <a id="35456" href="/Denot/#34982" class="Bound">v₂₁&#39;⊆v₂</a> <a id="35464" href="/Denot/#35451" class="Bound">x</a>
          <a id="35476" href="/Denot/#35372" class="Function">v₂&#39;⊆v₂</a> <a id="35483" class="Symbol">{</a><a id="35484" href="/Denot/#35484" class="Bound">C</a><a id="35485" class="Symbol">}</a> <a id="35487" class="Symbol">(</a><a id="35488" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="35493" href="/Denot/#35493" class="Bound">y</a><a id="35494" class="Symbol">)</a> <a id="35496" class="Symbol">=</a> <a id="35498" href="/Denot/#35053" class="Bound">v₂₂&#39;⊆v₂</a> <a id="35506" href="/Denot/#35493" class="Bound">y</a></pre>

<ul>
  <li>
    <p>Suppose u’ ≡ ⊥. Then we have a contradiction because
it is not the case that Fun ⊥.</p>
  </li>
  <li>
    <p>Suppose u’ ≡ u₁’ ↦ u₂’. Then u₁’ ↦ u₂’ ∈ u and we can apply the
premise (the induction hypothesis from u ⊑ v₂) to obtain that
u₁’ ↦ u₂’ factors of v₂ into v₂’. This case is complete because
dom u’ ≡ u₁’ and cod u’ ≡ u₂’.</p>
  </li>
  <li>
    <p>Suppose u’ ≡ u₁’ ⊔ u₂’. Then we have u₁’ ⊆ u and u₂’ ⊆ u. We also<br />
have Funs u₁’ and Funs u₂’, so we can apply the induction hypothesis
for both u₁’ and u₂’. So there exists values v₂₁’ and v₂₂’ such that
(dom u₁’) ↦ (cod u₁’) factors u into v₂₁’ and
(dom u₂’) ↦ (cod u₂’) factors u into v₂₂’.
We will show that (dom u) ↦ (cod u) factors u into (v₂₁’ ⊔ v₂₂’).
So we need to show that</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  dom (v₂₁' ⊔ v₂₂') ⊑ dom (u₁' ⊔ u₂')
  cod (u₁' ⊔ u₂') ⊑ cod (v₂₁' ⊔ v₂₂')
</code></pre></div>    </div>

    <p>But those both follow directly from the factoring of
u into v₂₁’ and v₂₂’, using the monotonicity of ⊔ with respect to ⊑.</p>
  </li>
</ul>

<h3 id="inversion-of-less-than-for-functions">Inversion of less-than for functions</h3>

<p>We come to the proof of the main lemma concerning the inversion of
less-than for functions. We show that if v₁ ⊑ v₂, then for any w₁ ↦
w₁’ ∈ v₁, we can factor v₂ into v₂’ according to w₁ ↦ w₁’. We proceed
by induction on the derivation of v₁ ⊑ v₂, and describe each case in
the text after the Agda proof.</p>

<pre class="Agda"><a id="sub-inv"></a><a id="36825" href="/Denot/#36825" class="Function">sub-inv</a> <a id="36833" class="Symbol">:</a> <a id="36835" class="Symbol">∀{</a><a id="36837" href="/Denot/#36837" class="Bound">v₁</a> <a id="36840" href="/Denot/#36840" class="Bound">v₂</a> <a id="36843" class="Symbol">:</a> <a id="36845" href="/Denot/#4101" class="Datatype">Value</a><a id="36850" class="Symbol">}</a>
        <a id="36860" class="Symbol">→</a> <a id="36862" href="/Denot/#36837" class="Bound">v₁</a> <a id="36865" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="36867" href="/Denot/#36840" class="Bound">v₂</a>
        <a id="36878" class="Symbol">→</a> <a id="36880" class="Symbol">∀{</a><a id="36882" href="/Denot/#36882" class="Bound">w₁</a> <a id="36885" href="/Denot/#36885" class="Bound">w₁&#39;</a><a id="36888" class="Symbol">}</a> <a id="36890" class="Symbol">→</a> <a id="36892" href="/Denot/#36882" class="Bound">w₁</a> <a id="36895" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="36897" href="/Denot/#36885" class="Bound">w₁&#39;</a> <a id="36901" href="/Denot/#28361" class="Function Operator">∈</a> <a id="36903" href="/Denot/#36837" class="Bound">v₁</a>
          <a id="36916" class="Comment">-------------------------------</a>
        <a id="36956" class="Symbol">→</a> <a id="36958" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">Σ[</a> <a id="36961" href="/Denot/#36961" class="Bound">v₂&#39;</a> <a id="36965" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">∈</a> <a id="36967" href="/Denot/#4101" class="Datatype">Value</a> <a id="36973" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">]</a> <a id="36975" href="/Denot/#33223" class="Function">factor</a> <a id="36982" href="/Denot/#36840" class="Bound">v₂</a> <a id="36985" href="/Denot/#36961" class="Bound">v₂&#39;</a> <a id="36989" href="/Denot/#36882" class="Bound">w₁</a> <a id="36992" href="/Denot/#36885" class="Bound">w₁&#39;</a>
<a id="36996" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37004" class="Symbol">{</a><a id="37005" href="/Denot/#4121" class="InductiveConstructor">⊥</a><a id="37006" class="Symbol">}</a> <a id="37008" class="Symbol">{</a><a id="37009" href="/Denot/#37009" class="Bound">v₂</a><a id="37011" class="Symbol">}</a> <a id="37013" href="/Denot/#4501" class="InductiveConstructor">Bot⊑</a> <a id="37018" class="Symbol">{</a><a id="37019" href="/Denot/#37019" class="Bound">w₁</a><a id="37021" class="Symbol">}</a> <a id="37023" class="Symbol">{</a><a id="37024" href="/Denot/#37024" class="Bound">w₁&#39;</a><a id="37027" class="Symbol">}</a> <a id="37029" class="Symbol">()</a>
<a id="37032" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37040" class="Symbol">{</a><a id="37041" href="/Denot/#37041" class="Bound">v₁₁</a> <a id="37045" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="37047" href="/Denot/#37047" class="Bound">v₁₂</a><a id="37050" class="Symbol">}</a> <a id="37052" class="Symbol">{</a><a id="37053" href="/Denot/#37053" class="Bound">v₂</a><a id="37055" class="Symbol">}</a> <a id="37057" class="Symbol">(</a><a id="37058" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="37065" href="/Denot/#37065" class="Bound">lt1</a> <a id="37069" href="/Denot/#37069" class="Bound">lt2</a><a id="37072" class="Symbol">)</a> <a id="37074" class="Symbol">{</a><a id="37075" href="/Denot/#37075" class="Bound">w₁</a><a id="37077" class="Symbol">}</a> <a id="37079" class="Symbol">{</a><a id="37080" href="/Denot/#37080" class="Bound">w₁&#39;</a><a id="37083" class="Symbol">}</a> <a id="37085" class="Symbol">(</a><a id="37086" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="37091" href="/Denot/#37091" class="Bound">x</a><a id="37092" class="Symbol">)</a> <a id="37094" class="Symbol">=</a> <a id="37096" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37104" href="/Denot/#37065" class="Bound">lt1</a> <a id="37108" href="/Denot/#37091" class="Bound">x</a>
<a id="37110" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37118" class="Symbol">{</a><a id="37119" href="/Denot/#37119" class="Bound">v₁₁</a> <a id="37123" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="37125" href="/Denot/#37125" class="Bound">v₁₂</a><a id="37128" class="Symbol">}</a> <a id="37130" class="Symbol">{</a><a id="37131" href="/Denot/#37131" class="Bound">v₂</a><a id="37133" class="Symbol">}</a> <a id="37135" class="Symbol">(</a><a id="37136" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="37143" href="/Denot/#37143" class="Bound">lt1</a> <a id="37147" href="/Denot/#37147" class="Bound">lt2</a><a id="37150" class="Symbol">)</a> <a id="37152" class="Symbol">{</a><a id="37153" href="/Denot/#37153" class="Bound">w₁</a><a id="37155" class="Symbol">}</a> <a id="37157" class="Symbol">{</a><a id="37158" href="/Denot/#37158" class="Bound">w₁&#39;</a><a id="37161" class="Symbol">}</a> <a id="37163" class="Symbol">(</a><a id="37164" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="37169" href="/Denot/#37169" class="Bound">y</a><a id="37170" class="Symbol">)</a> <a id="37172" class="Symbol">=</a> <a id="37174" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37182" href="/Denot/#37147" class="Bound">lt2</a> <a id="37186" href="/Denot/#37169" class="Bound">y</a>
<a id="37188" href="/Denot/#36825" class="CatchallClause Function">sub-inv</a><a id="37195" class="CatchallClause"> </a><a id="37196" class="CatchallClause Symbol">{</a><a id="37197" href="/Denot/#37197" class="CatchallClause Bound">v₁</a><a id="37199" class="CatchallClause Symbol">}</a><a id="37200" class="CatchallClause"> </a><a id="37201" class="CatchallClause Symbol">{</a><a id="37202" href="/Denot/#37202" class="CatchallClause Bound">v₂₁</a><a id="37205" class="CatchallClause"> </a><a id="37206" href="/Denot/#4163" class="CatchallClause InductiveConstructor Operator">⊔</a><a id="37207" class="CatchallClause"> </a><a id="37208" href="/Denot/#37208" class="CatchallClause Bound">v₂₂</a><a id="37211" class="CatchallClause Symbol">}</a><a id="37212" class="CatchallClause"> </a><a id="37213" class="CatchallClause Symbol">(</a><a id="37214" href="/Denot/#4627" class="CatchallClause InductiveConstructor">ConjR1⊑</a><a id="37221" class="CatchallClause"> </a><a id="37222" href="/Denot/#37222" class="CatchallClause Bound">lt</a><a id="37224" class="CatchallClause Symbol">)</a><a id="37225" class="CatchallClause"> </a><a id="37226" class="CatchallClause Symbol">{</a><a id="37227" href="/Denot/#37227" class="CatchallClause Bound">w₁</a><a id="37229" class="CatchallClause Symbol">}</a><a id="37230" class="CatchallClause"> </a><a id="37231" class="CatchallClause Symbol">{</a><a id="37232" href="/Denot/#37232" class="CatchallClause Bound">w₁&#39;</a><a id="37235" class="CatchallClause Symbol">}</a><a id="37236" class="CatchallClause"> </a><a id="37237" href="/Denot/#37237" class="CatchallClause Bound">m</a>
    <a id="37243" class="Keyword">with</a> <a id="37248" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37256" href="/Denot/#37222" class="Bound">lt</a> <a id="37259" href="/Denot/#37237" class="Bound">m</a>  
<a id="37263" class="Symbol">...</a> <a id="37267" class="Symbol">|</a> <a id="37269" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37271" href="/Denot/#37271" class="Bound">v₂₁&#39;</a> <a id="37276" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37278" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37280" href="/Denot/#37280" class="Bound">fv₂₁&#39;</a> <a id="37286" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37288" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37290" href="/Denot/#37290" class="Bound">v₂₁&#39;⊆v₂₁</a> <a id="37299" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37301" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37303" href="/Denot/#37303" class="Bound">domv₂₁&#39;⊑w₁</a> <a id="37314" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37316" href="/Denot/#37316" class="Bound">w₁&#39;⊑codv₂₁&#39;</a> <a id="37328" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37330" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37332" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37334" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37336" class="Symbol">=</a>
      <a id="37344" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37346" href="/Denot/#37271" class="Bound">v₂₁&#39;</a> <a id="37351" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37353" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37355" href="/Denot/#37280" class="Bound">fv₂₁&#39;</a> <a id="37361" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37363" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37365" class="Symbol">(λ</a> <a id="37368" class="Symbol">{</a><a id="37369" href="/Denot/#37369" class="Bound">w</a><a id="37370" class="Symbol">}</a> <a id="37372" href="/Denot/#37372" class="Bound">z</a> <a id="37374" class="Symbol">→</a> <a id="37376" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="37381" class="Symbol">(</a><a id="37382" href="/Denot/#37290" class="Bound">v₂₁&#39;⊆v₂₁</a> <a id="37391" href="/Denot/#37372" class="Bound">z</a><a id="37392" class="Symbol">))</a> <a id="37395" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a>
                                   <a id="37432" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37434" href="/Denot/#37303" class="Bound">domv₂₁&#39;⊑w₁</a> <a id="37445" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37447" href="/Denot/#37316" class="Bound">w₁&#39;⊑codv₂₁&#39;</a> <a id="37459" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37461" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37463" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37465" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="37467" href="/Denot/#36825" class="CatchallClause Function">sub-inv</a><a id="37474" class="CatchallClause"> </a><a id="37475" class="CatchallClause Symbol">{</a><a id="37476" href="/Denot/#37476" class="CatchallClause Bound">v₁</a><a id="37478" class="CatchallClause Symbol">}</a><a id="37479" class="CatchallClause"> </a><a id="37480" class="CatchallClause Symbol">{</a><a id="37481" href="/Denot/#37481" class="CatchallClause Bound">v₂₁</a><a id="37484" class="CatchallClause"> </a><a id="37485" href="/Denot/#4163" class="CatchallClause InductiveConstructor Operator">⊔</a><a id="37486" class="CatchallClause"> </a><a id="37487" href="/Denot/#37487" class="CatchallClause Bound">v₂₂</a><a id="37490" class="CatchallClause Symbol">}</a><a id="37491" class="CatchallClause"> </a><a id="37492" class="CatchallClause Symbol">(</a><a id="37493" href="/Denot/#4708" class="CatchallClause InductiveConstructor">ConjR2⊑</a><a id="37500" class="CatchallClause"> </a><a id="37501" href="/Denot/#37501" class="CatchallClause Bound">lt</a><a id="37503" class="CatchallClause Symbol">)</a><a id="37504" class="CatchallClause"> </a><a id="37505" class="CatchallClause Symbol">{</a><a id="37506" href="/Denot/#37506" class="CatchallClause Bound">w₁</a><a id="37508" class="CatchallClause Symbol">}</a><a id="37509" class="CatchallClause"> </a><a id="37510" class="CatchallClause Symbol">{</a><a id="37511" href="/Denot/#37511" class="CatchallClause Bound">w₁&#39;</a><a id="37514" class="CatchallClause Symbol">}</a><a id="37515" class="CatchallClause"> </a><a id="37516" href="/Denot/#37516" class="CatchallClause Bound">m</a>
    <a id="37522" class="Keyword">with</a> <a id="37527" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37535" href="/Denot/#37501" class="Bound">lt</a> <a id="37538" href="/Denot/#37516" class="Bound">m</a>  
<a id="37542" class="Symbol">...</a> <a id="37546" class="Symbol">|</a> <a id="37548" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37550" href="/Denot/#37550" class="Bound">v₂₂&#39;</a> <a id="37555" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37557" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37559" href="/Denot/#37559" class="Bound">fv₂₂&#39;</a> <a id="37565" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37567" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37569" href="/Denot/#37569" class="Bound">v₂₂&#39;⊆v₂₂</a> <a id="37578" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37580" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37582" href="/Denot/#37582" class="Bound">domv₂₂&#39;⊑w₁</a> <a id="37593" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37595" href="/Denot/#37595" class="Bound">w₁&#39;⊑codv₂₂&#39;</a> <a id="37607" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37609" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37611" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37613" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37615" class="Symbol">=</a>
      <a id="37623" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37625" href="/Denot/#37550" class="Bound">v₂₂&#39;</a> <a id="37630" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37632" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37634" href="/Denot/#37559" class="Bound">fv₂₂&#39;</a> <a id="37640" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37642" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37644" class="Symbol">(λ</a> <a id="37647" class="Symbol">{</a><a id="37648" href="/Denot/#37648" class="Bound">C</a><a id="37649" class="Symbol">}</a> <a id="37651" href="/Denot/#37651" class="Bound">z</a> <a id="37653" class="Symbol">→</a> <a id="37655" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="37660" class="Symbol">(</a><a id="37661" href="/Denot/#37569" class="Bound">v₂₂&#39;⊆v₂₂</a> <a id="37670" href="/Denot/#37651" class="Bound">z</a><a id="37671" class="Symbol">))</a> <a id="37674" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a>
                                   <a id="37711" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37713" href="/Denot/#37582" class="Bound">domv₂₂&#39;⊑w₁</a> <a id="37724" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37726" href="/Denot/#37595" class="Bound">w₁&#39;⊑codv₂₂&#39;</a> <a id="37738" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37740" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37742" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37744" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="37746" href="/Denot/#36825" class="CatchallClause Function">sub-inv</a><a id="37753" class="CatchallClause"> </a><a id="37754" class="CatchallClause Symbol">{</a><a id="37755" href="/Denot/#37755" class="CatchallClause Bound">v₁</a><a id="37757" class="CatchallClause Symbol">}</a><a id="37758" class="CatchallClause"> </a><a id="37759" class="CatchallClause Symbol">{</a><a id="37760" href="/Denot/#37760" class="CatchallClause Bound">v₂</a><a id="37762" class="CatchallClause Symbol">}</a><a id="37763" class="CatchallClause"> </a><a id="37764" class="CatchallClause Symbol">(</a><a id="37765" href="/Denot/#4789" class="CatchallClause InductiveConstructor">Trans⊑</a><a id="37771" class="CatchallClause Symbol">{</a><a id="37772" class="CatchallClause Argument">v₂</a><a id="37774" class="CatchallClause"> </a><a id="37775" class="CatchallClause Symbol">=</a><a id="37776" class="CatchallClause"> </a><a id="37777" href="/Denot/#37777" class="CatchallClause Bound">u</a><a id="37778" class="CatchallClause Symbol">}</a><a id="37779" class="CatchallClause"> </a><a id="37780" href="/Denot/#37780" class="CatchallClause Bound">v₁⊑u</a><a id="37784" class="CatchallClause"> </a><a id="37785" href="/Denot/#37785" class="CatchallClause Bound">u⊑v₂</a><a id="37789" class="CatchallClause Symbol">)</a><a id="37790" class="CatchallClause"> </a><a id="37791" class="CatchallClause Symbol">{</a><a id="37792" href="/Denot/#37792" class="CatchallClause Bound">w₁</a><a id="37794" class="CatchallClause Symbol">}</a><a id="37795" class="CatchallClause"> </a><a id="37796" class="CatchallClause Symbol">{</a><a id="37797" href="/Denot/#37797" class="CatchallClause Bound">w₁&#39;</a><a id="37800" class="CatchallClause Symbol">}</a><a id="37801" class="CatchallClause"> </a><a id="37802" href="/Denot/#37802" class="CatchallClause Bound">w₁↦w₁&#39;∈v₁</a>
    <a id="37816" class="Keyword">with</a> <a id="37821" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37829" href="/Denot/#37780" class="Bound">v₁⊑u</a> <a id="37834" href="/Denot/#37802" class="Bound">w₁↦w₁&#39;∈v₁</a>
<a id="37844" class="Symbol">...</a> <a id="37848" class="Symbol">|</a> <a id="37850" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37852" href="/Denot/#37852" class="Bound">u&#39;</a> <a id="37855" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37857" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37859" href="/Denot/#37859" class="Bound">fu&#39;</a> <a id="37863" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37865" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37867" href="/Denot/#37867" class="Bound">u&#39;⊆u</a> <a id="37872" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37874" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37876" href="/Denot/#37876" class="Bound">domu&#39;⊑w₁</a> <a id="37885" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37887" href="/Denot/#37887" class="Bound">w₁&#39;⊑codu&#39;</a> <a id="37897" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37899" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37901" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="37903" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> 
    <a id="37910" class="Keyword">with</a> <a id="37915" href="/Denot/#34310" class="Function">sub-inv-trans</a> <a id="37929" class="Symbol">{</a><a id="37930" href="/Denot/#37852" class="Bound">u&#39;</a><a id="37932" class="Symbol">}</a> <a id="37934" href="/Denot/#37859" class="Bound">fu&#39;</a> <a id="37938" href="/Denot/#37867" class="Bound">u&#39;⊆u</a> <a id="37943" class="Symbol">(</a><a id="37944" href="/Denot/#36825" class="Function">sub-inv</a> <a id="37952" class="Bound">u⊑v₂</a><a id="37956" class="Symbol">)</a> 
<a id="37959" class="Symbol">...</a> <a id="37963" class="Symbol">|</a> <a id="37965" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37967" href="/Denot/#37967" class="Bound">v₂&#39;</a> <a id="37971" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37973" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37975" href="/Denot/#37975" class="Bound">fv₂&#39;</a> <a id="37980" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37982" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37984" href="/Denot/#37984" class="Bound">v₂&#39;⊆v₂</a> <a id="37991" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="37993" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="37995" href="/Denot/#37995" class="Bound">domv₂&#39;⊑domu&#39;</a> <a id="38008" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38010" href="/Denot/#38010" class="Bound">codu&#39;⊑codv₂&#39;</a> <a id="38023" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38025" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38027" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38029" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38031" class="Symbol">=</a>
      <a id="38039" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38041" href="/Denot/#37967" class="Bound">v₂&#39;</a> <a id="38045" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38047" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38049" href="/Denot/#37975" class="Bound">fv₂&#39;</a> <a id="38054" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38056" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38058" href="/Denot/#37984" class="Bound">v₂&#39;⊆v₂</a> <a id="38065" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38067" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38069" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="38076" href="/Denot/#37995" class="Bound">domv₂&#39;⊑domu&#39;</a> <a id="38089" class="Bound">domu&#39;⊑w₁</a> <a id="38098" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a>
                                    <a id="38136" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="38143" class="Bound">w₁&#39;⊑codu&#39;</a> <a id="38153" href="/Denot/#38010" class="Bound">codu&#39;⊑codv₂&#39;</a> <a id="38166" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38168" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38170" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38172" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="38174" href="/Denot/#36825" class="Function">sub-inv</a> <a id="38182" class="Symbol">{</a><a id="38183" href="/Denot/#38183" class="Bound">v₁₁</a> <a id="38187" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38189" href="/Denot/#38189" class="Bound">v₁₂</a><a id="38192" class="Symbol">}</a> <a id="38194" class="Symbol">{</a><a id="38195" href="/Denot/#38195" class="Bound">v₂₁</a> <a id="38199" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38201" href="/Denot/#38201" class="Bound">v₂₂</a><a id="38204" class="Symbol">}</a> <a id="38206" class="Symbol">(</a><a id="38207" href="/Denot/#4875" class="InductiveConstructor">Fun⊑</a> <a id="38212" href="/Denot/#38212" class="Bound">lt1</a> <a id="38216" href="/Denot/#38216" class="Bound">lt2</a><a id="38219" class="Symbol">)</a> <a id="38221" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="38226" class="Symbol">=</a>
    <a id="38232" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38234" href="/Denot/#38195" class="Bound">v₂₁</a> <a id="38238" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38240" href="/Denot/#38201" class="Bound">v₂₂</a> <a id="38244" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38246" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38248" class="Symbol">(λ</a> <a id="38251" class="Symbol">{</a><a id="38252" href="/Denot/#38252" class="Bound">v&#39;</a><a id="38254" class="Symbol">}</a> <a id="38256" class="Symbol">→</a> <a id="38258" href="/Denot/#30407" class="InductiveConstructor">fun</a><a id="38261" class="Symbol">)</a> <a id="38263" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38265" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38267" class="Symbol">(λ</a> <a id="38270" class="Symbol">{</a><a id="38271" href="/Denot/#38271" class="Bound">C</a><a id="38272" class="Symbol">}</a> <a id="38274" href="/Denot/#38274" class="Bound">z</a> <a id="38276" class="Symbol">→</a> <a id="38278" href="/Denot/#38274" class="Bound">z</a><a id="38279" class="Symbol">)</a> <a id="38281" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38283" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38285" href="/Denot/#38212" class="Bound">lt1</a> <a id="38289" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38291" href="/Denot/#38216" class="Bound">lt2</a> <a id="38295" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38297" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38299" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38301" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
<a id="38303" href="/Denot/#36825" class="Function">sub-inv</a> <a id="38311" class="Symbol">{</a><a id="38312" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38316" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38318" class="Symbol">(</a><a id="38319" href="/Denot/#38319" class="Bound">v₂₂</a> <a id="38323" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="38325" href="/Denot/#38325" class="Bound">v₂₃</a><a id="38328" class="Symbol">)}</a> <a id="38331" class="Symbol">{</a><a id="38332" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38336" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38338" href="/Denot/#38319" class="Bound">v₂₂</a> <a id="38342" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="38344" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38348" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38350" href="/Denot/#38325" class="Bound">v₂₃</a><a id="38353" class="Symbol">}</a> <a id="38355" href="/Denot/#4997" class="InductiveConstructor">Dist⊑</a>
    <a id="38365" class="Symbol">{</a><a id="38366" class="DottedPattern Symbol">.</a><a id="38367" href="/Denot/#38312" class="DottedPattern Bound">v₂₁</a><a id="38370" class="Symbol">}</a> <a id="38372" class="Symbol">{</a><a id="38373" class="DottedPattern Symbol">.(</a><a id="38375" href="/Denot/#38319" class="DottedPattern Bound">v₂₂</a> <a id="38379" href="/Denot/#4163" class="DottedPattern InductiveConstructor Operator">⊔</a> <a id="38381" href="/Denot/#38325" class="DottedPattern Bound">v₂₃</a><a id="38384" class="DottedPattern Symbol">)</a><a id="38385" class="Symbol">}</a> <a id="38387" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="38392" class="Symbol">=</a>
    <a id="38398" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38400" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38404" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38406" href="/Denot/#38319" class="Bound">v₂₂</a> <a id="38410" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="38412" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38416" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38418" href="/Denot/#38325" class="Bound">v₂₃</a> <a id="38422" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38424" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38426" href="/Denot/#38481" class="Function">f</a> <a id="38428" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38430" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38432" href="/Denot/#38576" class="Function">g</a> <a id="38434" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38436" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="38438" href="/Denot/#4525" class="InductiveConstructor">ConjL⊑</a> <a id="38445" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="38451" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="38457" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="38459" href="/Denot/#5698" class="Function">Refl⊑</a> <a id="38465" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38467" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38469" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="38471" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
  <a id="38475" class="Keyword">where</a> <a id="38481" href="/Denot/#38481" class="Function">f</a> <a id="38483" class="Symbol">:</a> <a id="38485" href="/Denot/#30450" class="Function">Funs</a> <a id="38490" class="Symbol">(</a><a id="38491" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38495" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38497" href="/Denot/#38319" class="Bound">v₂₂</a> <a id="38501" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="38503" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38507" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38509" href="/Denot/#38325" class="Bound">v₂₃</a><a id="38512" class="Symbol">)</a>
        <a id="38522" href="/Denot/#38481" class="Function">f</a> <a id="38524" class="Symbol">(</a><a id="38525" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="38530" href="/Denot/#38530" class="Bound">x</a><a id="38531" class="Symbol">)</a> <a id="38533" class="Symbol">=</a> <a id="38535" href="/Denot/#30407" class="InductiveConstructor">fun</a> <a id="38539" href="/Denot/#38530" class="Bound">x</a>
        <a id="38549" href="/Denot/#38481" class="Function">f</a> <a id="38551" class="Symbol">(</a><a id="38552" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="38557" href="/Denot/#38557" class="Bound">y</a><a id="38558" class="Symbol">)</a> <a id="38560" class="Symbol">=</a> <a id="38562" href="/Denot/#30407" class="InductiveConstructor">fun</a> <a id="38566" href="/Denot/#38557" class="Bound">y</a>
        <a id="38576" href="/Denot/#38576" class="Function">g</a> <a id="38578" class="Symbol">:</a> <a id="38580" class="Symbol">(</a><a id="38581" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38585" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38587" href="/Denot/#38319" class="Bound">v₂₂</a> <a id="38591" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="38593" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38597" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38599" href="/Denot/#38325" class="Bound">v₂₃</a><a id="38602" class="Symbol">)</a> <a id="38604" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="38606" class="Symbol">(</a><a id="38607" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38611" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38613" href="/Denot/#38319" class="Bound">v₂₂</a> <a id="38617" href="/Denot/#4163" class="InductiveConstructor Operator">⊔</a> <a id="38619" href="/Denot/#38312" class="Bound">v₂₁</a> <a id="38623" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="38625" href="/Denot/#38325" class="Bound">v₂₃</a><a id="38628" class="Symbol">)</a>
        <a id="38638" href="/Denot/#38576" class="Function">g</a> <a id="38640" class="Symbol">(</a><a id="38641" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="38646" href="/Denot/#38646" class="Bound">x</a><a id="38647" class="Symbol">)</a> <a id="38649" class="Symbol">=</a> <a id="38651" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#475" class="InductiveConstructor">inj₁</a> <a id="38656" href="/Denot/#38646" class="Bound">x</a>
        <a id="38666" href="/Denot/#38576" class="Function">g</a> <a id="38668" class="Symbol">(</a><a id="38669" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="38674" href="/Denot/#38674" class="Bound">y</a><a id="38675" class="Symbol">)</a> <a id="38677" class="Symbol">=</a> <a id="38679" href="https://agda.github.io/agda-stdlib/Data.Sum.Base.html#500" class="InductiveConstructor">inj₂</a> <a id="38684" href="/Denot/#38674" class="Bound">y</a></pre>

<p>Let w₁ w₁’ be arbitrary values.</p>

<ul>
  <li>
    <p>Case (Bot⊑). So v₁ ≡ ⊥. We have w₁ ↦ w₁’ ∈ ⊥, but that is impossible.</p>
  </li>
  <li>
    <p>Case (ConjL⊑).</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  v₁₁ ⊑ v₂   v₁₂ ⊑ v₂
  -------------------
  v₁₁ ⊔ v₁₂ ⊑ v₂
</code></pre></div>    </div>

    <p>Given that w₁ ↦ w₁’ ∈ v₁₁ ⊔ v₁₂, there are two subcases to consider.</p>

    <ul>
      <li>
        <p>Subcase w₁ ↦ w₁’ ∈ v₁₁. We conclude by the induction
hypothesis for v₁₁ ⊑ v₂.</p>
      </li>
      <li>
        <p>Subcase w₁ ↦ w₁’ ∈ v₁₂. We conclude by the induction hypothesis
for v₁₂ ⊑ v₂.</p>
      </li>
    </ul>
  </li>
  <li>
    <p>Case (ConjR1⊑).</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  v₁ ⊑ v₂₁
  --------------
  v₁ ⊑ v₂₁ ⊔ v₂₂
</code></pre></div>    </div>

    <p>Given that w₁ ↦ w₁’ ∈ v₁, the induction hypothesis for v₁ ⊑ v₂₁
gives us that w₁ ↦ w₁’ factors v₂₁ into v₂₁’ for some v₂₁’.
To show that w₁ ↦ w₁’ also factors (v₂₁ ⊔ v₂₂) into v₂₁’,
we just need to show that v₂₁’ ⊆ v₂₁ ⊔ v₂₂, but that follows
directly from v₂₁’ ⊆ v₂₁.</p>
  </li>
  <li>
    <p>Case (ConjR2⊑). This case follows by reasoning similar to
the case for (ConjR1⊑).</p>
  </li>
  <li>
    <p>Case (Trans⊑).</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  v₁ ⊑ u   u ⊑ v₂
  ---------------
      v₁ ⊑ v₂
</code></pre></div>    </div>

    <p>By the induction hypothesis for v₁ ⊑ u, we know
that w₁ ↦ w₁’ factors u into u’, for some value u’,
so we have Funs u’ and u’ ⊆ u.
By the induction hypothesis for u ⊑ v₂, we know
that for any u₁ ↦ u₂ ∈ u, u₁ ↦ u₂ factors v₂ into v₂’.
Now we apply the lemma sub-inv-trans, which gives us
some v₂’ such that (dom u’) ↦ (cod u’) factors v₂ into v₂’.
We show that w₁ ↦ w₁’ also factors v₂ into v₂’.
From dom v₂’ ⊑ dom u’ and dom u’ ⊑ w₁, we have dom v₂’ ⊑ w₁.
From w₁’ ⊑ cod u’ and cod u’ ⊑ cod v₂’, we have w₁’ ⊑ cod v₂’,
and this case is complete.</p>
  </li>
  <li>
    <p>Case (Fun⊑).</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  v₂₁ ⊑ v₁₁  v₁₂ ⊑ v₂₂
  ---------------------
  v₁₁ ↦ v₁₂ ⊑ v₂₁ ↦ v₂₂
</code></pre></div>    </div>

    <p>Given that w₁ ↦ w₁’ ∈ v₁₁ ↦ v₁₂, we have w₁ ≡ v₁₁ and w₁’ ≡ v₁₂.
We show that v₁₁ ↦ v₁₂ factors v₂₁ ↦ v₂₂ into itself.
We need to show that dom (v₂₁ ↦ v₂₂) ⊑ v₁₁ and v₁₂ ⊑ cod (v₂₁ ↦ v₂₂),
but that is equivalent to our premises v₂₁ ⊑ v₁₁ and v₁₂ ⊑ v₂₂.</p>
  </li>
  <li>
    <p>Case (Dist⊑).</p>

    <div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  ---------------------------------------------
  v₂₁ ↦ (v₂₂ ⊔ v₂₃) ⊑ (v₂₁ ↦ v₂₂) ⊔ (v₂₁ ↦ v₂₃)
</code></pre></div>    </div>

    <p>Given that w₁ ↦ w₁’ ∈ v₂₁ ↦ (v₂₂ ⊔ v₂₃), we have w₁ ≡ v₂₁
and w₁’ ≡ v₂₂ ⊔ v₂₃.
We show that v₂₁ ↦ (v₂₂ ⊔ v₂₃) factors (v₂₁ ↦ v₂₂) ⊔ (v₂₁ ↦ v₂₃) into itself.
We have v₂₁ ⊔ v₂₁ ⊑ v₂₁, and also
v₂₂ ⊔ v₂₃ ⊑ v₂₂ ⊔ v₂₃, so the proof is complete.</p>
  </li>
</ul>

<p>We conclude this section with two corollaries of the sub-inv lemma.
First, we have the following property that is convenient to use in
later proofs. We specialize the premise to just (v₁ ↦ v₁’) ⊑ v₂
and we modify the conclusion to say that for every
w ↦ w’ ∈ v₂’, we have w ⊑ v₁.</p>

<pre class="Agda"><a id="sub-inv-fun"></a><a id="41305" href="/Denot/#41305" class="Function">sub-inv-fun</a> <a id="41317" class="Symbol">:</a> <a id="41319" class="Symbol">∀{</a><a id="41321" href="/Denot/#41321" class="Bound">v₁</a> <a id="41324" href="/Denot/#41324" class="Bound">v₁&#39;</a> <a id="41328" href="/Denot/#41328" class="Bound">v₂</a> <a id="41331" class="Symbol">:</a> <a id="41333" href="/Denot/#4101" class="Datatype">Value</a><a id="41338" class="Symbol">}</a>
    <a id="41344" class="Symbol">→</a> <a id="41346" class="Symbol">(</a><a id="41347" href="/Denot/#41321" class="Bound">v₁</a> <a id="41350" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="41352" href="/Denot/#41324" class="Bound">v₁&#39;</a><a id="41355" class="Symbol">)</a> <a id="41357" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="41359" href="/Denot/#41328" class="Bound">v₂</a>
      <a id="41368" class="Comment">-----------------------------------------------------</a>
    <a id="41426" class="Symbol">→</a> <a id="41428" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">Σ[</a> <a id="41431" href="/Denot/#41431" class="Bound">v₂&#39;</a> <a id="41435" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">∈</a> <a id="41437" href="/Denot/#4101" class="Datatype">Value</a> <a id="41443" href="https://agda.github.io/agda-stdlib/Data.Product.html#764" class="Function">]</a> <a id="41445" href="/Denot/#30450" class="Function">Funs</a> <a id="41450" href="/Denot/#41431" class="Bound">v₂&#39;</a> <a id="41454" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="41456" href="/Denot/#41431" class="Bound">v₂&#39;</a> <a id="41460" href="/Denot/#28629" class="Function Operator">⊆</a> <a id="41462" href="/Denot/#41328" class="Bound">v₂</a>
        <a id="41473" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="41475" class="Symbol">(∀{</a><a id="41478" href="/Denot/#41478" class="Bound">w</a> <a id="41480" href="/Denot/#41480" class="Bound">w&#39;</a><a id="41482" class="Symbol">}</a> <a id="41484" class="Symbol">→</a> <a id="41486" class="Symbol">(</a><a id="41487" href="/Denot/#41478" class="Bound">w</a> <a id="41489" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="41491" href="/Denot/#41480" class="Bound">w&#39;</a><a id="41493" class="Symbol">)</a> <a id="41495" href="/Denot/#28361" class="Function Operator">∈</a> <a id="41497" href="/Denot/#41431" class="Bound">v₂&#39;</a> <a id="41501" class="Symbol">→</a> <a id="41503" href="/Denot/#41478" class="Bound">w</a> <a id="41505" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="41507" href="/Denot/#41321" class="Bound">v₁</a><a id="41509" class="Symbol">)</a> <a id="41511" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="41513" href="/Denot/#41324" class="Bound">v₁&#39;</a> <a id="41517" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="41519" href="/Denot/#31677" class="Function">cod</a> <a id="41523" href="/Denot/#41431" class="Bound">v₂&#39;</a>
<a id="41527" href="/Denot/#41305" class="Function">sub-inv-fun</a><a id="41538" class="Symbol">{</a><a id="41539" href="/Denot/#41539" class="Bound">v₁</a><a id="41541" class="Symbol">}{</a><a id="41543" href="/Denot/#41543" class="Bound">v₁&#39;</a><a id="41546" class="Symbol">}{</a><a id="41548" href="/Denot/#41548" class="Bound">v₂</a><a id="41550" class="Symbol">}</a> <a id="41552" href="/Denot/#41552" class="Bound">abc</a>
    <a id="41560" class="Keyword">with</a> <a id="41565" href="/Denot/#36825" class="Function">sub-inv</a> <a id="41573" href="/Denot/#41552" class="Bound">abc</a> <a id="41577" class="Symbol">{</a><a id="41578" href="/Denot/#41539" class="Bound">v₁</a><a id="41580" class="Symbol">}{</a><a id="41582" href="/Denot/#41543" class="Bound">v₁&#39;</a><a id="41585" class="Symbol">}</a> <a id="41587" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a>
<a id="41592" class="Symbol">...</a> <a id="41596" class="Symbol">|</a> <a id="41598" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="41600" href="/Denot/#41600" class="Bound">v₂&#39;</a> <a id="41604" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="41606" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="41608" href="/Denot/#41608" class="Bound">f</a> <a id="41610" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="41612" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="41614" href="/Denot/#41614" class="Bound">v₂&#39;⊆v₂</a> <a id="41621" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="41623" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="41625" href="/Denot/#41625" class="Bound">db</a> <a id="41628" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="41630" href="/Denot/#41630" class="Bound">cc</a> <a id="41633" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="41635" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="41637" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="41639" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="41641" class="Symbol">=</a>
      <a id="41649" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="41651" href="/Denot/#41600" class="Bound">v₂&#39;</a> <a id="41655" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="41657" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="41659" href="/Denot/#41608" class="Bound">f</a> <a id="41661" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="41663" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="41665" href="/Denot/#41614" class="Bound">v₂&#39;⊆v₂</a> <a id="41672" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="41674" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="41676" href="/Denot/#41700" class="Function">G</a> <a id="41678" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="41680" href="/Denot/#41630" class="Bound">cc</a> <a id="41683" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="41685" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="41687" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="41689" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
   <a id="41694" class="Keyword">where</a> <a id="41700" href="/Denot/#41700" class="Function">G</a> <a id="41702" class="Symbol">:</a> <a id="41704" class="Symbol">∀{</a><a id="41706" href="/Denot/#41706" class="Bound">D</a> <a id="41708" href="/Denot/#41708" class="Bound">E</a><a id="41709" class="Symbol">}</a> <a id="41711" class="Symbol">→</a> <a id="41713" class="Symbol">(</a><a id="41714" href="/Denot/#41706" class="Bound">D</a> <a id="41716" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="41718" href="/Denot/#41708" class="Bound">E</a><a id="41719" class="Symbol">)</a> <a id="41721" href="/Denot/#28361" class="Function Operator">∈</a> <a id="41723" href="/Denot/#41600" class="Bound">v₂&#39;</a> <a id="41727" class="Symbol">→</a> <a id="41729" href="/Denot/#41706" class="Bound">D</a> <a id="41731" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="41733" class="Bound">v₁</a>
         <a id="41745" href="/Denot/#41700" class="Function">G</a><a id="41746" class="Symbol">{</a><a id="41747" href="/Denot/#41747" class="Bound">D</a><a id="41748" class="Symbol">}{</a><a id="41750" href="/Denot/#41750" class="Bound">E</a><a id="41751" class="Symbol">}</a> <a id="41753" href="/Denot/#41753" class="Bound">m</a> <a id="41755" class="Symbol">=</a> <a id="41757" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="41764" class="Symbol">(</a><a id="41765" href="/Denot/#29140" class="Function">⊆→⊑</a> <a id="41769" class="Symbol">(</a><a id="41770" href="/Denot/#31968" class="Function">↦∈→⊆dom</a> <a id="41778" href="/Denot/#41608" class="Bound">f</a> <a id="41780" href="/Denot/#41753" class="Bound">m</a><a id="41781" class="Symbol">))</a> <a id="41784" href="/Denot/#41625" class="Bound">db</a></pre>

<p>The second corollary is the inversion rule that one would expect for
less-than with functions on the left and right-hand sides.</p>

<pre class="Agda"><a id="↦⊑↦-inv"></a><a id="41941" href="/Denot/#41941" class="Function">↦⊑↦-inv</a> <a id="41949" class="Symbol">:</a> <a id="41951" class="Symbol">∀{</a><a id="41953" href="/Denot/#41953" class="Bound">v₁</a> <a id="41956" href="/Denot/#41956" class="Bound">v₂</a> <a id="41959" href="/Denot/#41959" class="Bound">v₃</a> <a id="41962" href="/Denot/#41962" class="Bound">v₄</a><a id="41964" class="Symbol">}</a>
        <a id="41974" class="Symbol">→</a> <a id="41976" href="/Denot/#41953" class="Bound">v₁</a> <a id="41979" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="41981" href="/Denot/#41956" class="Bound">v₂</a> <a id="41984" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="41986" href="/Denot/#41959" class="Bound">v₃</a> <a id="41989" href="/Denot/#4133" class="InductiveConstructor Operator">↦</a> <a id="41991" href="/Denot/#41962" class="Bound">v₄</a>
          <a id="42004" class="Comment">-----------------</a>
        <a id="42030" class="Symbol">→</a> <a id="42032" href="/Denot/#41959" class="Bound">v₃</a> <a id="42035" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="42037" href="/Denot/#41953" class="Bound">v₁</a> <a id="42040" href="https://agda.github.io/agda-stdlib/Data.Product.html#1353" class="Function Operator">×</a> <a id="42042" href="/Denot/#41956" class="Bound">v₂</a> <a id="42045" href="/Denot/#4466" class="Datatype Operator">⊑</a> <a id="42047" href="/Denot/#41962" class="Bound">v₄</a>
<a id="42050" href="/Denot/#41941" class="Function">↦⊑↦-inv</a><a id="42057" class="Symbol">{</a><a id="42058" href="/Denot/#42058" class="Bound">v₁</a><a id="42060" class="Symbol">}{</a><a id="42062" href="/Denot/#42062" class="Bound">v₂</a><a id="42064" class="Symbol">}{</a><a id="42066" href="/Denot/#42066" class="Bound">v₃</a><a id="42068" class="Symbol">}{</a><a id="42070" href="/Denot/#42070" class="Bound">v₄</a><a id="42072" class="Symbol">}</a> <a id="42074" href="/Denot/#42074" class="Bound">lt</a>
    <a id="42081" class="Keyword">with</a> <a id="42086" href="/Denot/#41305" class="Function">sub-inv-fun</a> <a id="42098" href="/Denot/#42074" class="Bound">lt</a>  
<a id="42103" class="Symbol">...</a> <a id="42107" class="Symbol">|</a> <a id="42109" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="42111" href="/Denot/#42111" class="Bound">Γ</a> <a id="42113" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="42115" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="42117" href="/Denot/#42117" class="Bound">f</a> <a id="42119" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="42121" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="42123" href="/Denot/#42123" class="Bound">Γ⊆v34</a> <a id="42129" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="42131" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="42133" href="/Denot/#42133" class="Bound">lt1</a> <a id="42137" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="42139" href="/Denot/#42139" class="Bound">lt2</a> <a id="42143" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="42145" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="42147" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="42149" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
    <a id="42155" class="Keyword">with</a> <a id="42160" href="/Denot/#30796" class="Function">Funs∈</a> <a id="42166" href="/Denot/#42117" class="Bound">f</a>
<a id="42168" class="Symbol">...</a> <a id="42172" class="Symbol">|</a> <a id="42174" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="42176" href="/Denot/#42176" class="Bound">A</a> <a id="42178" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="42180" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="42182" href="/Denot/#42182" class="Bound">A&#39;</a> <a id="42185" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="42187" href="/Denot/#42187" class="Bound">A↦A&#39;∈Γ</a> <a id="42194" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a> <a id="42196" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a>
    <a id="42202" class="Keyword">with</a> <a id="42207" class="Bound">Γ⊆v34</a> <a id="42213" href="/Denot/#42187" class="Bound">A↦A&#39;∈Γ</a>
<a id="42220" class="Symbol">...</a> <a id="42224" class="Symbol">|</a> <a id="42226" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Equality.html#140" class="InductiveConstructor">refl</a> <a id="42231" class="Symbol">=</a>    
  <a id="42239" class="Keyword">let</a> <a id="42243" href="/Denot/#42243" class="Bound">codΓ⊆v₄</a> <a id="42251" class="Symbol">=</a> <a id="42253" href="/Denot/#32538" class="Function">⊆↦→cod⊆</a> <a id="42261" class="Bound">Γ⊆v34</a> <a id="42267" class="Keyword">in</a>
  <a id="42272" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟨</a> <a id="42274" class="Bound">lt1</a> <a id="42278" class="Bound">A↦A&#39;∈Γ</a> <a id="42285" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">,</a> <a id="42287" href="/Denot/#4789" class="InductiveConstructor">Trans⊑</a> <a id="42294" class="Bound">lt2</a> <a id="42298" class="Symbol">(</a><a id="42299" href="/Denot/#29140" class="Function">⊆→⊑</a> <a id="42303" href="/Denot/#42243" class="Bound">codΓ⊆v₄</a><a id="42310" class="Symbol">)</a> <a id="42312" href="https://agda.github.io/agda-stdlib/Agda.Builtin.Sigma.html#139" class="InductiveConstructor Operator">⟩</a></pre>

<h2 id="notes">Notes</h2>

<p>[JGS: todo: reorganize these notes for the new chapters]</p>

<p>The denotational semantics presented in this chapter is an example of
a <em>filter model</em> (Barendregt, Coppo, Dezani-Ciancaglini, 1983). Filter
models use type systems with intersection types to precisely
characterize runtime behavior (Coppo, Dezani-Ciancaglini, and Salle,
1979). The notation that we use in this chapter is not that of type
systems and intersection types, but the Value data type is isomorphic
to types (↦ is →, ⊔ is ∧, ⊥ is ⊤), the ⊑ relation is the inverse of
subtyping &lt;:, and the evaluation relation ρ ⊢ M ↓ v is isomorphic to a
type system. Write Γ instead of ρ, A instead of v, and replace ↓ with : and
one has Γ ⊢ M : A.  By varying the definition of subtyping and
using different choices of type atoms, intersection type systems can
provide semantics for many different untyped λ calculi, from full beta
to the lazy and call-by-value calculi (Alessi, Barbanera, and
Dezani-Ciancaglini, 2006) (Rocca and Paolini, 2004).  The denotational
semantics in this chapter corresponds to the BCD system (Barendregt,
Coppo, Dezani-Ciancaglini, 1983).  Part 3 of the book <em>Lambda Calculus
with Types</em> describes a framework for intersection type systems that
enables results similar to the ones in this chapter, but for the
entire family of intersection type systems (Barendregt, Dekkers, and
Statman, 2013).</p>

<p>The two ideas of using finite tables to represent functions and of
relaxing table lookup to enable self application first appeared in a
technical report by Gordon Plotkin (1972) and are later described in
an article in Theoretical Computer Science (Plotkin 1993).  In that
work, the inductive definition of Value is a bit different than the
one we use:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Value = C + ℘f(Value) × ℘f(Value)
</code></pre></div></div>

<p>where C is a set of constants and ℘f means finite powerset.  The pairs
in ℘f(Value) × ℘f(Value) represent input-output mappings, just as in
this chapter. The finite powersets are used to enable a function table
to appear in the input and in the output. These differences amount to
changing where the recursion appears in the definition of Value.
Plotkin’s model is an example of a <em>graph model</em> of the untyped lambda
calculus (Barendregt, 1984). In a graph model, the semantics is
presented as a function from programs and environments to (possibly
infinite) sets of values. The semantics in this chapter is instead
defined as a relation, but set-valued functions are isomorphic to
relations. We choose to present the semantics as a relation because
the functional approach requires a kind of existential quantifier that
is not present in Agda.</p>

<p>[PLW: What kind of existential is required?]</p>

<p>Dana Scott’s ℘(ω) (1976) and Engeler’s B(A) (1981) are two more
examples of graph models. Both use the following inductive definition
of Value.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Value = C + ℘f(Value) × Value
</code></pre></div></div>

<p>The use of Value instead of ℘f(Value) in the output does not restrict
expressiveness compared to Plotkin’s model because the semantics use
sets of values and a pair of sets (V, V’) can be represented as a set
of pairs { (V, v’) | v’ ∈ V’ }.  In Scott’s ℘(ω), the above values are
mapped to and from the natural numbers using a kind of Godel encoding.</p>

<h2 id="references">References</h2>

<ul>
  <li>
    <p>Intersection Types and Lambda Models.  Fabio Alessi, Franco
Barbanera, and Mariangiola Dezani-Ciancaglini, Theoretical
Compututer Science, vol. 355, pages 108-126, 2006.</p>
  </li>
  <li>
    <p>The Lambda Calculus. H.P. Barendregt, 1984.</p>
  </li>
  <li>
    <p>A filter lambda model and the completeness of type assignment.  Henk
Barendregt, Mario Coppo, and Mariangiola Dezani-Ciancaglini, Journal
of Symbolic Logic, vol. 48, pages 931-940, 1983.</p>
  </li>
  <li>
    <p>Lambda Calculus with Types. Henk Barendregt, Wil Dekkers, and
Richard Statman, Cambridge University Press, Perspectives in Logic,
2013.</p>
  </li>
  <li>
    <p>Functional characterization of some semantic equalities inside
λ-calculus. Mario Coppo, Mariangiola Dezani-Ciancaglini, and Patrick
Salle, in Sixth Colloquium on Automata, Languages and Programming.
Springer, pages 133–146, 1979.</p>
  </li>
  <li>
    <p>Algebras and combinators. Erwin Engeler, Algebra Universalis,
vol. 13, pages 389-392, 1981.</p>
  </li>
  <li>
    <p>A Set-Theoretical Definition of Application. Gordon D. Plotkin,
University of Edinburgh, Technical Report MIP-R-95, 1972.</p>
  </li>
  <li>
    <p>Set-theoretical and other elementary models of the λ-calculus.
Gordon D. Plotkin, Theoretical Computer Science, vol. 121,
pages 351-409, 1993.</p>
  </li>
  <li>
    <p>The Parametric Lambda Calculus. Simona Ronchi Della Rocca and Luca
Paolini, Springer, 2004.</p>
  </li>
  <li>
    <p>Data Types as Lattices. Dana Scott, SIAM Journal on Computing,
vol. 5, pages 522-587, 1976.</p>
  </li>
</ul>


  </div>

  <p style="text-align:center;">
    
    <a alt="Previous chapter" href="/Untyped/">Prev</a>
    &bullet;
    
    
    <a alt="Source code" href="https://github.com/plfa/plfa.github.io/blob/dev/src/plfa/Denot.lagda">Source</a>
    
    
    &bullet;
    <a alt="Next chapter" href="/DenotCompositional/">Next</a>
    
</p>


</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programming Language Foundations in Agda
</h2><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Philip Wadler</li>
          <li><a class="u-email" href="mailto:wadler@inf.ed.ac.uk">wadler@inf.ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wadler"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wadler</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div><div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Wen Kokke</li>
          <li><a class="u-email" href="mailto:wen.kokke@ed.ac.uk">wen.kokke@ed.ac.uk</a></li>
        </ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">wenkokke</span></a></li><li><a href="https://www.twitter.com/wenkokke"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#twitter"></use></svg> <span class="username">wenkokke</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3"></div>
    </div>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by/4.0/">Creative Commons Attribution 4.0 International License</a>
  </div>
</footer>
<!-- Import jQuery -->
<script type="text/javascript" src="/assets/jquery.js"></script>

<!-- Script which allows for foldable code blocks -->
<script type="text/javascript">
 $('div.foldable pre').each(function(){
     var autoHeight = $(this).height();
     var lineHeight = parseFloat($(this).css('line-height'));

     var plus    = $("<div></div>");
     var horLine = $("<div></div>");
     var verLine = $("<div></div>");
     $(this).prepend(plus);
     plus.css({
         'position'         : 'relative',
         'float'            : 'right',
         'right'            : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'width'            : lineHeight,
         'height'           : lineHeight});
     verLine.css({
         'position'         : 'relative',
         'height'           : lineHeight,
         'width'            : '3px',
         'background-color' : '#C1E0FF'});
     horLine.css({
         'position'         : 'relative',
         'top'              : '-' + (0.5 * lineHeight + 1.5) + 'px',
         'left'             : '-' + (0.5 * lineHeight - 1.5) + 'px',
         'height'           : '3px',
         'width'            : lineHeight,
         'background-color' : '#C1E0FF'});
     plus.append(verLine);
     plus.append(horLine);

     $(this).height(2.0 * lineHeight);
     $(this).css('overflow','hidden');

     $(this).click(function(){
         if ($(this).height() == autoHeight) {
             $(this).height(2.0 * lineHeight);
             plus.show();
         }
         else {
             $(this).height('auto');
             plus.hide();
         }
     });
 });
</script>

<!-- Import KaTeX -->
<script type="text/javascript" src="/assets/katex.js"></script>

<!-- Script which renders TeX using KaTeX -->
<script type="text/javascript">
 $("script[type='math/tex']").replaceWith(
     function(){
         var tex = $(this).text();
         return "<span class=\"inline-equation\">" +
                katex.renderToString(tex) +
                "</span>";
     });
 $("script[type='math/tex; mode=display']").replaceWith(
     function(){
         var tex = $(this).text().replace(/%.*?(\n|$)/g,"");
         return "<div class=\"equation\">" +
                katex.renderToString("\\displaystyle "+tex) +
                "</div>";
     });
</script>
</body>

</html>
